#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'net/http'
require 'json'
require_relative '../lib/familyrecipes'

PROJECT_ROOT = File.expand_path('..', __dir__)
NUTRITION_PATH = File.join(PROJECT_ROOT, 'resources/nutrition-data.yaml')
GROCERY_PATH = File.join(PROJECT_ROOT, 'resources/grocery-info.yaml')
RECIPES_DIR = File.join(PROJECT_ROOT, 'recipes')

Helpers = FamilyRecipes::NutritionEntryHelpers

# FDA label order: 11 nutrients
NUTRIENTS = [
  { key: 'calories',      label: 'Calories', unit: '', indent: 0 },
  { key: 'fat',           label: 'Total fat',       unit: 'g',  indent: 0 },
  { key: 'saturated_fat', label: 'Saturated fat',   unit: 'g',  indent: 1 },
  { key: 'trans_fat',     label: 'Trans fat',       unit: 'g',  indent: 1 },
  { key: 'cholesterol',   label: 'Cholesterol',     unit: 'mg', indent: 0 },
  { key: 'sodium',        label: 'Sodium',          unit: 'mg', indent: 0 },
  { key: 'carbs',         label: 'Total carbs',     unit: 'g',  indent: 0 },
  { key: 'fiber',         label: 'Fiber',           unit: 'g',  indent: 1 },
  { key: 'total_sugars',  label: 'Total sugars',    unit: 'g',  indent: 1 },
  { key: 'added_sugars',  label: 'Added sugars',    unit: 'g',  indent: 2 },
  { key: 'protein',       label: 'Protein',         unit: 'g',  indent: 0 }
].freeze

# USDA nutrient number -> our key (per 100g basis)
NUTRIENT_MAP = {
  '208' => 'calories',      # Energy (kcal)
  '204' => 'fat',           # Total lipid (fat)
  '606' => 'saturated_fat', # Fatty acids, total saturated
  '605' => 'trans_fat',     # Fatty acids, total trans
  '601' => 'cholesterol',   # Cholesterol
  '307' => 'sodium',        # Sodium
  '205' => 'carbs',         # Carbohydrate, by difference
  '291' => 'fiber',         # Fiber, total dietary
  '269' => 'total_sugars',  # Sugars, total
  '203' => 'protein'        # Protein
}.freeze

VOLUME_UNITS = %w[cup cups tbsp tablespoon tablespoons tsp teaspoon teaspoons].freeze

# --- Data I/O ---

def load_nutrition_data
  return {} unless File.exist?(NUTRITION_PATH)

  YAML.safe_load_file(NUTRITION_PATH, permitted_classes: [], permitted_symbols: [], aliases: false) || {}
end

def save_nutrition_data(data)
  sorted = data.sort_by { |k, _| k.downcase }.to_h

  sorted.each_value do |entry|
    entry['nutrients'].transform_values! { |v| v.is_a?(Float) ? v.round(4) : v } if entry['nutrients'].is_a?(Hash)
    entry['portions'].transform_values! { |v| v.is_a?(Float) ? v.round(2) : v } if entry['portions'].is_a?(Hash)
    next unless entry['density'].is_a?(Hash)

    entry['density']['grams'] = entry['density']['grams'].round(2) if entry['density']['grams'].is_a?(Float)
    entry['density']['volume'] = entry['density']['volume'].round(4) if entry['density']['volume'].is_a?(Float)
  end

  File.write(NUTRITION_PATH, YAML.dump(sorted))
  puts "Saved to #{NUTRITION_PATH}"
end

# --- Context loading and name resolution ---

def load_context
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
  recipes = FamilyRecipes.parse_recipes(RECIPES_DIR)
  recipe_map = recipes.to_h { |r| [r.id, r] }
  omit_set = (grocery_aisles['Omit_From_List'] || []).flat_map do |item|
    [item[:name], *item[:aliases]].map(&:downcase)
  end.to_set

  { grocery_aisles: grocery_aisles, alias_map: alias_map, recipes: recipes,
    recipe_map: recipe_map, omit_set: omit_set }
end

def resolve_name(raw_name, ctx)
  canonical = ctx[:alias_map][raw_name.downcase]
  if canonical
    puts "  -> Resolved to \"#{canonical}\"" if canonical != raw_name
    return canonical
  end

  puts "  \"#{raw_name}\" not found in grocery-info.yaml. Recipes won't match this entry."
  print '  Continue anyway? (y/n): '
  input = $stdin.gets&.strip
  return nil unless input&.downcase == 'y'

  raw_name
end

def find_needed_units(name, ctx)
  units = Set.new
  ctx[:recipes].each do |recipe|
    recipe.all_ingredients_with_quantities(ctx[:alias_map], ctx[:recipe_map]).each do |ing_name, amounts|
      next unless ing_name == name

      amounts.each do |amount|
        next if amount.nil?

        _, unit = amount
        units << unit
      end
    end
  end
  units.to_a
end

# --- API key ---

def load_api_key
  return ENV['USDA_API_KEY'] if ENV['USDA_API_KEY']

  env_path = File.join(PROJECT_ROOT, '.env')
  return nil unless File.exist?(env_path)

  File.readlines(env_path).each do |line|
    key, value = line.strip.split('=', 2)
    return value if key == 'USDA_API_KEY' && value && !value.empty?
  end
  nil
end

# --- USDA API interaction ---

def search_usda(api_key, query)
  uri = URI('https://api.nal.usda.gov/fdc/v1/foods/search')
  body = {
    query: query,
    dataType: ['SR Legacy'],
    pageSize: 10
  }.to_json

  request = Net::HTTP::Post.new(uri, 'Content-Type' => 'application/json')
  request['X-Api-Key'] = api_key
  request.body = body

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
  JSON.parse(response.body)
end

def fetch_usda_detail(api_key, fdc_id)
  uri = URI("https://api.nal.usda.gov/fdc/v1/food/#{fdc_id}")
  request = Net::HTTP::Get.new(uri)
  request['X-Api-Key'] = api_key

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
  JSON.parse(response.body)
end

# --- USDA data extraction ---

def extract_nutrients(food_detail)
  nutrients = { 'basis_grams' => 100.0 }
  NUTRIENT_MAP.each_value { |key| nutrients[key] = 0.0 }

  food_detail['foodNutrients']&.each do |fn|
    number = fn.dig('nutrient', 'number')
    next unless number

    our_key = NUTRIENT_MAP[number]
    next unless our_key

    nutrients[our_key] = (fn['amount'] || 0.0).round(4)
  end

  # added_sugars not in SR Legacy â€” default to 0
  nutrients['added_sugars'] = 0.0

  nutrients
end

def volume_unit?(modifier)
  clean = modifier.to_s.downcase.sub(/\s*\(.*\)/, '').strip
  VOLUME_UNITS.include?(clean)
end

def normalize_volume_unit(modifier)
  clean = modifier.to_s.downcase.sub(/\s*\(.*\)/, '').strip
  case clean
  when 'cups' then 'cup'
  when 'tablespoon', 'tablespoons' then 'tbsp'
  when 'teaspoon', 'teaspoons' then 'tsp'
  else clean
  end
end

def classify_portions(food_detail)
  volume = []
  non_volume = []

  food_detail['foodPortions']&.each do |portion|
    modifier = portion['modifier'].to_s
    next if modifier.empty?

    grams = portion['gramWeight']
    amount = portion['amount'] || 1.0
    next unless grams&.positive?

    entry = { modifier: modifier, grams: grams, amount: amount }

    if volume_unit?(modifier)
      volume << entry
    else
      non_volume << entry
    end
  end

  { volume: volume, non_volume: non_volume }
end

def pick_density(volume_portions)
  return nil if volume_portions.empty?

  best = volume_portions.max_by { |p| p[:grams] }
  unit = normalize_volume_unit(best[:modifier])

  { 'grams' => best[:grams].round(2), 'volume' => best[:amount], 'unit' => unit }
end

def build_non_volume_portions(classified)
  classified[:non_volume].to_h do |p|
    unit = p[:modifier].downcase.sub(/\s*\(.*\)/, '').strip
    grams = (p[:grams] / p[:amount]).round(2)
    [unit, grams]
  end
end

# --- Display helpers ---

def display_entry(name, entry)
  puts "\n--- #{name} ---"

  basis = entry.dig('nutrients', 'basis_grams') || '?'
  puts "  Nutrients (per #{basis}g):"
  NUTRIENTS.each do |n|
    indent = '  ' * n[:indent]
    value = entry.dig('nutrients', n[:key]) || 0
    unit_str = n[:unit].empty? ? '' : " #{n[:unit]}"
    puts "    #{indent}#{n[:label]}: #{value}#{unit_str}"
  end

  density = entry['density']
  if density
    puts "  Density: #{density['grams']}g per #{density['volume']} #{density['unit']}"
  else
    puts '  Density: none'
  end

  portions = entry['portions'] || {}
  if portions.any?
    puts "  Portions: #{portions.map { |k, v| "#{k}=#{v}g" }.join(', ')}"
  else
    puts '  Portions: none'
  end

  puts "  Source: #{entry['source']}" if entry['source']
end

def display_unit_coverage(name, entry, needed_units)
  return if needed_units.empty?

  calculator = FamilyRecipes::NutritionCalculator.new({ name => entry })
  entry_data = calculator.nutrition_data[name]
  return unless entry_data

  puts "\n  Unit coverage for recipes:"
  needed_units.each do |unit|
    label = unit || '(bare count)'
    resolved = calculator.resolvable?(1, unit, entry_data)
    status = resolved ? 'OK' : 'MISSING'
    puts "    #{label}: #{status}"
  end
end
