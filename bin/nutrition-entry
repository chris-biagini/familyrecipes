#!/usr/bin/env ruby
require 'bundler/setup'
require_relative '../lib/familyrecipes'

PROJECT_ROOT = File.expand_path("..", __dir__)
NUTRITION_PATH = File.join(PROJECT_ROOT, "resources/nutrition-data.yaml")
GROCERY_PATH = File.join(PROJECT_ROOT, "resources/grocery-info.yaml")
RECIPES_DIR = File.join(PROJECT_ROOT, "recipes")

NUTRIENTS = %w[calories protein fat carbs fiber sodium].freeze

def load_nutrition_data
  if File.exist?(NUTRITION_PATH)
    YAML.safe_load_file(NUTRITION_PATH, permitted_classes: [], permitted_symbols: [], aliases: false) || {}
  else
    {}
  end
end

def save_nutrition_data(data)
  File.write(NUTRITION_PATH, YAML.dump(data))
  puts "Saved to #{NUTRITION_PATH}"
end

def find_missing_ingredients(nutrition_data)
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
  recipes = FamilyRecipes.parse_recipes(RECIPES_DIR)

  omit_set = Set.new
  if grocery_aisles["Omit_From_List"]
    grocery_aisles["Omit_From_List"].each do |item|
      omit_set << item[:name].downcase
      item[:aliases].each { |al| omit_set << al.downcase }
    end
  end

  ingredients_to_recipes = Hash.new { |h, k| h[k] = [] }
  recipes.each do |recipe|
    recipe.all_ingredient_names(alias_map).each do |name|
      ingredients_to_recipes[name] << recipe.title unless omit_set.include?(name.downcase)
    end
  end

  missing = ingredients_to_recipes.keys.reject { |name| nutrition_data.key?(name) }.sort
  [missing, ingredients_to_recipes]
end

def parse_serving_size(input)
  # Extract gram weight from serving size strings like:
  #   "30g", "2 Tbsp / 30g", "2 Tbsp (30g)", "About 14 crackers (30g)"
  grams_match = input.match(/(\d+(?:\.\d+)?)\s*g\b/)
  return nil unless grams_match

  grams = grams_match[1].to_f
  return nil if grams <= 0

  result = { grams: grams }

  # Try to extract a unit+amount for auto-portion (e.g., "2 Tbsp" from "2 Tbsp / 30g")
  # Look for pattern like "NUMBER UNIT" before the gram weight
  portion_match = input.match(/^(\d+(?:\.\d+)?)\s+(Tbsp|tbsp|tsp|cup|slice|stick|serving|piece|item)\b/i)
  if portion_match
    result[:amount] = portion_match[1].to_f
    result[:unit] = portion_match[2]
  end

  result
end

def convert_to_per_100g(per_serving, serving_grams)
  factor = 100.0 / serving_grams
  per_serving.transform_values { |v| (v * factor).round(2) }
end

def prompt_nutrients
  puts "\nEnter per-serving values from the label:"
  values = {}
  NUTRIENTS.each do |nutrient|
    unit = nutrient == 'sodium' ? 'mg' : (nutrient == 'calories' ? 'kcal' : 'g')
    print "  #{nutrient} (#{unit}): "
    input = $stdin.gets&.strip
    return nil if input.nil?
    values[nutrient] = Float(input) rescue 0.0
  end
  values
end

def prompt_portions(existing_portions, auto_portion: nil)
  portions = {}

  puts "\nPortion weights (grams per unit). Enter = accept, '-' = skip, 'done' = finish."
  puts "Units handled automatically by the calculator: g, oz, lbs, kg, ml, l"

  # Auto-suggest from serving size
  if auto_portion
    unit = auto_portion[:unit]
    grams_per_unit = (auto_portion[:grams] / auto_portion[:amount]).round(1)
    print "  #{unit} [#{grams_per_unit}] (from label): "
    input = $stdin.gets&.strip
    if input != '-' && input&.downcase != 'done'
      if input.nil? || input.empty?
        portions[unit] = grams_per_unit
      else
        value = Float(input) rescue nil
        portions[unit] = value if value
      end
    end
    return portions if input&.downcase == 'done'
  end

  # Show existing portions if re-entering
  if existing_portions && !existing_portions.empty?
    puts "  Existing portions:"
    existing_portions.each do |unit, grams|
      print "    #{unit} [#{grams}]: "
      input = $stdin.gets&.strip
      if input != '-' && input&.downcase != 'done'
        if input.nil? || input.empty?
          portions[unit] = grams
        else
          value = Float(input) rescue nil
          portions[unit] = value if value
        end
      end
      return portions if input&.downcase == 'done'
    end
  end

  # Common units
  common = %w[cup Tbsp tsp ~unitless]
  common.each do |unit|
    next if portions.key?(unit)
    next if existing_portions&.key?(unit)
    print "  #{unit}: "
    input = $stdin.gets&.strip
    break if input&.downcase == 'done'
    next if input.nil? || input.empty? || input == '-'
    value = Float(input) rescue nil
    portions[unit] = value if value
  end

  # Custom units
  loop do
    print "  Additional unit (or Enter to finish): "
    input = $stdin.gets&.strip
    break if input.nil? || input.empty?

    print "    grams per 1 #{input}: "
    value_str = $stdin.gets&.strip
    value = Float(value_str) rescue nil
    portions[input] = value if value
  end

  portions
end

def enter_ingredient(name, nutrition_data)
  existing = nutrition_data[name]
  if existing
    puts "\n#{name} already has data:"
    puts "  per_100g: #{existing['per_100g'].map { |k, v| "#{k}=#{v}" }.join(', ')}"
    puts "  portions: #{(existing['portions'] || {}).map { |k, v| "#{k}=#{v}g" }.join(', ')}"
    print "Overwrite? (y/n): "
    input = $stdin.gets&.strip
    return unless input&.downcase == 'y'
  end

  puts "\n--- #{name} ---"
  print "Serving size from label (e.g. '2 Tbsp / 30g' or '30g'): "
  serving_input = $stdin.gets&.strip
  return if serving_input.nil? || serving_input.empty?

  parsed = parse_serving_size(serving_input)
  unless parsed
    puts "Could not extract gram weight from '#{serving_input}'."
    puts "Please include the gram weight, e.g. '30g' or '2 Tbsp / 30g'"
    return
  end

  serving_grams = parsed[:grams]
  puts "Serving size: #{serving_grams}g (factor: #{(100.0 / serving_grams).round(4)}x)"

  per_serving = prompt_nutrients
  return unless per_serving

  per_100g = convert_to_per_100g(per_serving, serving_grams)

  puts "\nConverted to per 100g:"
  per_100g.each { |k, v| puts "  #{k}: #{v}" }

  auto_portion = if parsed[:unit] && parsed[:amount]
    { unit: parsed[:unit], grams: parsed[:grams], amount: parsed[:amount] }
  end

  existing_portions = existing&.dig('portions')
  portions = prompt_portions(existing_portions, auto_portion: auto_portion)

  entry = { 'per_100g' => per_100g }
  entry['portions'] = portions unless portions.empty?

  puts "\nFinal entry for #{name}:"
  puts YAML.dump({ name => entry }).lines[1..].join

  print "\nSave? (y/n): "
  confirm = $stdin.gets&.strip
  if confirm&.downcase == 'y'
    nutrition_data[name] = entry
    save_nutrition_data(nutrition_data)
  else
    puts "Discarded."
  end
end

# --- Main ---

if ARGV.include?('--help') || ARGV.include?('-h')
  puts "Usage:"
  puts "  bin/nutrition-entry                    Enter data interactively (prompts for ingredient)"
  puts "  bin/nutrition-entry \"Cream cheese\"     Enter data for a specific ingredient"
  puts "  bin/nutrition-entry --missing           List ingredients missing nutrition data"
  puts ""
  puts "Nutrition values are entered from package labels (per-serving) and"
  puts "converted to per-100g for storage in resources/nutrition-data.yaml."
  exit 0
end

nutrition_data = load_nutrition_data

if ARGV.include?('--missing')
  missing, ingredients_to_recipes = find_missing_ingredients(nutrition_data)

  if missing.empty?
    puts "All ingredients have nutrition data!"
    exit 0
  end

  puts "#{missing.length} ingredients missing nutrition data:\n\n"
  missing.each_with_index do |name, i|
    recipes = ingredients_to_recipes[name].uniq.sort
    puts "  #{i + 1}. #{name} (in: #{recipes.join(', ')})"
  end
else
  ingredient_name = ARGV.reject { |a| a.start_with?('-') }.first

  unless ingredient_name
    print "Ingredient name: "
    ingredient_name = $stdin.gets&.strip
  end

  if ingredient_name.nil? || ingredient_name.empty?
    $stderr.puts "No ingredient name provided."
    exit 1
  end

  enter_ingredient(ingredient_name, nutrition_data)
end
