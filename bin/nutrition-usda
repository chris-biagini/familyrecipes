#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'net/http'
require 'json'
require_relative '../lib/familyrecipes'

PROJECT_ROOT = File.expand_path('..', __dir__)
NUTRITION_PATH = File.join(PROJECT_ROOT, 'resources/nutrition-data.yaml')
GROCERY_PATH = File.join(PROJECT_ROOT, 'resources/grocery-info.yaml')
RECIPES_DIR = File.join(PROJECT_ROOT, 'recipes')

# USDA nutrient number -> our key (per 100g basis)
NUTRIENT_MAP = {
  '208' => 'calories',     # Energy (kcal)
  '204' => 'fat',          # Total lipid (fat)
  '606' => 'saturated_fat', # Fatty acids, total saturated
  '605' => 'trans_fat',     # Fatty acids, total trans
  '601' => 'cholesterol',   # Cholesterol
  '307' => 'sodium',        # Sodium
  '205' => 'carbs',         # Carbohydrate, by difference
  '291' => 'fiber',         # Fiber, total dietary
  '269' => 'total_sugars',  # Sugars, total
  '203' => 'protein'        # Protein
}.freeze

VOLUME_UNITS = %w[cup cups tbsp tablespoon tablespoons tsp teaspoon teaspoons].freeze

# --- API key ---

def load_api_key
  env_path = File.join(PROJECT_ROOT, '.env')
  return ENV['USDA_API_KEY'] if ENV['USDA_API_KEY']

  if File.exist?(env_path)
    File.readlines(env_path).each do |line|
      key, value = line.strip.split('=', 2)
      return value if key == 'USDA_API_KEY' && value && !value.empty?
    end
  end

  nil
end

# --- API interaction ---

def search_usda(api_key, query)
  uri = URI('https://api.nal.usda.gov/fdc/v1/foods/search')
  body = {
    query: query,
    dataType: ['SR Legacy'],
    pageSize: 10
  }.to_json

  request = Net::HTTP::Post.new(uri, 'Content-Type' => 'application/json')
  request['X-Api-Key'] = api_key
  request.body = body

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
  JSON.parse(response.body)
end

def fetch_usda_detail(api_key, fdc_id)
  uri = URI("https://api.nal.usda.gov/fdc/v1/food/#{fdc_id}")
  request = Net::HTTP::Get.new(uri)
  request['X-Api-Key'] = api_key

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
  JSON.parse(response.body)
end

# --- Data extraction ---

def extract_nutrients(food_detail)
  nutrients = { 'basis_grams' => 100.0 }

  # Default all to 0
  NUTRIENT_MAP.each_value { |key| nutrients[key] = 0.0 }

  food_detail['foodNutrients']&.each do |fn|
    number = fn.dig('nutrient', 'number')
    next unless number

    our_key = NUTRIENT_MAP[number]
    next unless our_key

    nutrients[our_key] = (fn['amount'] || 0.0).round(4)
  end

  # added_sugars not in SR Legacy â€” default to 0
  nutrients['added_sugars'] = 0.0

  nutrients
end

def volume_unit?(modifier)
  clean = modifier.to_s.downcase.sub(/\s*\(.*\)/, '').strip
  VOLUME_UNITS.include?(clean)
end

def normalize_volume_unit(modifier)
  clean = modifier.to_s.downcase.sub(/\s*\(.*\)/, '').strip
  case clean
  when 'cups' then 'cup'
  when 'tablespoon', 'tablespoons' then 'tbsp'
  when 'teaspoon', 'teaspoons' then 'tsp'
  else clean
  end
end

def classify_portions(food_detail)
  volume = []
  non_volume = []

  food_detail['foodPortions']&.each do |portion|
    modifier = portion['modifier'].to_s
    next if modifier.empty?

    grams = portion['gramWeight']
    amount = portion['amount'] || 1.0
    next unless grams&.positive?

    entry = { modifier: modifier, grams: grams, amount: amount }

    if volume_unit?(modifier)
      volume << entry
    else
      non_volume << entry
    end
  end

  { volume: volume, non_volume: non_volume }
end

def pick_density(volume_portions)
  return nil if volume_portions.empty?

  # Pick the largest by gram weight for best precision
  best = volume_portions.max_by { |p| p[:grams] }
  unit = normalize_volume_unit(best[:modifier])

  { 'grams' => best[:grams].round(2), 'volume' => best[:amount], 'unit' => unit }
end

# --- Shared utilities (same logic as nutrition-entry) ---

def load_nutrition_data
  if File.exist?(NUTRITION_PATH)
    YAML.safe_load_file(NUTRITION_PATH, permitted_classes: [], permitted_symbols: [], aliases: false) || {}
  else
    {}
  end
end

def save_nutrition_data(data)
  sorted = data.sort_by { |k, _| k.downcase }.to_h

  sorted.each_value do |entry|
    entry['nutrients'].transform_values! { |v| v.is_a?(Float) ? v.round(4) : v } if entry['nutrients'].is_a?(Hash)
    entry['portions'].transform_values! { |v| v.is_a?(Float) ? v.round(2) : v } if entry['portions'].is_a?(Hash)
    entry.dig('density', 'grams')&.then { |g| entry['density']['grams'] = g.round(2) if g.is_a?(Float) }
  end

  File.write(NUTRITION_PATH, YAML.dump(sorted))
  puts "Saved to #{NUTRITION_PATH}"
end

def resolve_name(raw_name)
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)

  canonical = alias_map[raw_name.downcase]
  if canonical
    puts "  -> Resolved to \"#{canonical}\"" if canonical != raw_name
    return canonical
  end

  puts "  \"#{raw_name}\" not found in grocery-info.yaml. Recipes won't match this entry."
  print '  Continue anyway? (y/n): '
  input = $stdin.gets&.strip
  return nil unless input&.downcase == 'y'

  raw_name
end

def find_needed_units(name)
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
  recipes = FamilyRecipes.parse_recipes(RECIPES_DIR)
  recipe_map = recipes.to_h { |r| [r.id, r] }

  units = Set.new
  recipes.each do |recipe|
    recipe.all_ingredients_with_quantities(alias_map, recipe_map).each do |ing_name, amounts|
      next unless ing_name == name

      amounts.each do |amount|
        next if amount.nil?

        _, unit = amount
        units << unit
      end
    end
  end
  units.to_a
end

def find_missing_ingredients(nutrition_data)
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
  recipes = FamilyRecipes.parse_recipes(RECIPES_DIR)

  omit_set = (grocery_aisles['Omit_From_List'] || []).flat_map do |item|
    [item[:name], *item[:aliases]].map(&:downcase)
  end.to_set

  ingredients_to_recipes = Hash.new { |h, k| h[k] = [] }
  recipes.each do |recipe|
    recipe.all_ingredient_names(alias_map).each do |name|
      ingredients_to_recipes[name] << recipe.title unless omit_set.include?(name.downcase)
    end
  end

  missing = ingredients_to_recipes.keys.reject { |name| nutrition_data.key?(name) }
  missing_with_counts = missing.map { |name| [name, ingredients_to_recipes[name].uniq.size] }
  missing_with_counts.sort_by { |_, count| -count }.map(&:first)
end

# --- Interactive workflow ---

def display_search_results(foods)
  foods.each_with_index do |food, idx|
    puts "  #{idx + 1}. [#{food['fdcId']}] #{food['description']} (#{food['dataType']})"
  end
end

def search_and_pick(api_key, name)
  default_query = name.sub(/\s*\(.*\)/, '').strip

  loop do
    print "\nSearch USDA [#{default_query}]: "
    input = $stdin.gets&.strip
    return nil if input&.downcase == 'q'

    query = input.nil? || input.empty? ? default_query : input

    puts "Searching for \"#{query}\"..."
    result = search_usda(api_key, query)
    foods = result['foods'] || []

    if foods.empty?
      puts '  No results found. Try a different search.'
      next
    end

    puts "\nResults:"
    display_search_results(foods)
    puts '  s. Search again'
    puts '  q. Skip this ingredient'

    print "\nPick (1-#{foods.size}): "
    choice = $stdin.gets&.strip
    return nil if choice&.downcase == 'q'
    next if choice&.downcase == 's'

    idx = choice.to_i - 1
    next unless idx >= 0 && idx < foods.size

    fdc_id = foods[idx]['fdcId']
    puts "\nFetching detail for #{foods[idx]['description']}..."
    return fetch_usda_detail(api_key, fdc_id)
  end
end

def display_nutrients(nutrients)
  puts '  Nutrients (per 100g):'
  nutrients.each do |key, value|
    next if key == 'basis_grams'

    puts "    #{key}: #{value}"
  end
end

def display_density(density)
  return puts '  Density: none (no volume portions found)' unless density

  puts "  Density: #{density['grams']}g per #{density['volume']} #{density['unit']}"
end

def display_portions(portions)
  return puts '  Non-volume portions: none' if portions.empty?

  puts '  Non-volume portions:'
  portions.each { |k, v| puts "    #{k}: #{v}g" }
end

def show_unit_coverage(name, entry, needed_units)
  return if needed_units.empty?

  calculator = FamilyRecipes::NutritionCalculator.new({ name => entry })
  entry_data = calculator.nutrition_data[name]
  return unless entry_data

  puts "\n  Unit coverage for recipes:"
  needed_units.each do |unit|
    label = unit || '(bare count)'
    resolved = calculator.resolvable?(1, unit, entry_data)
    status = resolved ? 'OK' : 'MISSING'
    puts "    #{label}: #{status}"
  end
end

def build_non_volume_portions(classified, needed_units)
  portions = {}

  classified[:non_volume].each do |p|
    # Use modifier as portion name, normalize
    unit = p[:modifier].downcase.sub(/\s*\(.*\)/, '').strip
    grams = (p[:grams] / p[:amount]).round(2)

    # Map "large", "medium", "small" + item to ~unitless if it looks like a countable
    if unit.match?(/\A(large|medium|small|extra large)\z/i)
      portions['~unitless'] ||= grams
      next
    end

    portions[unit] = grams
  end

  # If recipes use bare count and no ~unitless yet, check if there's exactly one non-volume portion
  if needed_units.include?(nil) && !portions.key?('~unitless') && classified[:non_volume].size == 1
    portions['~unitless'] = (classified[:non_volume].first[:grams] / classified[:non_volume].first[:amount]).round(2)
  end

  portions
end

def process_ingredient(api_key, name, nutrition_data)
  existing = nutrition_data[name]
  if existing
    puts "\n#{name} already has data."
    if existing['nutrients']
      puts "  nutrients: #{existing['nutrients'].except('basis_grams').map { |k, v| "#{k}=#{v}" }.join(', ')}"
    end
    print 'Overwrite? (y/n): '
    input = $stdin.gets&.strip
    return unless input&.downcase == 'y'
  end

  food_detail = search_and_pick(api_key, name)
  return unless food_detail

  puts "\n--- #{name} (from: #{food_detail['description']}) ---"

  nutrients = extract_nutrients(food_detail)
  classified = classify_portions(food_detail)
  density = pick_density(classified[:volume])
  needed_units = find_needed_units(name)
  portions = build_non_volume_portions(classified, needed_units)

  display_nutrients(nutrients)
  display_density(density)
  display_portions(portions)

  # Build entry
  entry = { 'nutrients' => nutrients }
  entry['density'] = density if density
  entry['portions'] = portions unless portions.empty?
  entry['source'] = "USDA SR Legacy (FDC #{food_detail['fdcId']})"

  show_unit_coverage(name, entry, needed_units)

  puts "\nFinal entry:"
  puts YAML.dump({ name => entry }).lines[1..].join

  print "\nSave? (y/n): "
  confirm = $stdin.gets&.strip
  if confirm&.downcase == 'y'
    nutrition_data[name] = entry
    save_nutrition_data(nutrition_data)
  else
    puts 'Discarded.'
  end
end

# --- Main ---

if ARGV.include?('--help') || ARGV.include?('-h')
  puts 'Usage:'
  puts '  bin/nutrition-usda                     Interactive prompt'
  puts '  bin/nutrition-usda "Flour"             Import data for a specific ingredient'
  puts '  bin/nutrition-usda --missing           Batch: iterate missing ingredients'
  puts ''
  puts 'Queries the USDA FoodData Central API (SR Legacy dataset) and saves'
  puts 'nutrition data in density-first format to resources/nutrition-data.yaml.'
  puts ''
  puts 'Requires USDA_API_KEY in .env or environment. Get a free key at:'
  puts '  https://fdc.nal.usda.gov/api-key-signup'
  exit 0
end

api_key = load_api_key
unless api_key
  warn 'USDA_API_KEY not found. Set it in .env or as an environment variable.'
  warn 'Get a free key at: https://fdc.nal.usda.gov/api-key-signup'
  exit 1
end

nutrition_data = load_nutrition_data

if ARGV.include?('--missing')
  missing = find_missing_ingredients(nutrition_data)

  if missing.empty?
    puts 'All ingredients have nutrition data!'
    exit 0
  end

  puts "#{missing.size} ingredients missing nutrition data.\n\n"

  missing.each do |name|
    puts "--- #{name} ---"
    print 'Search USDA? (y/n/q): '
    input = $stdin.gets&.strip
    break if input&.downcase == 'q'
    next unless input&.downcase == 'y'

    process_ingredient(api_key, name, nutrition_data)
    puts ''
  end
else
  ingredient_name = ARGV.reject { |a| a.start_with?('-') }.first

  unless ingredient_name
    print 'Ingredient name: '
    ingredient_name = $stdin.gets&.strip
  end

  if ingredient_name.nil? || ingredient_name.empty?
    warn 'No ingredient name provided.'
    exit 1
  end

  resolved = resolve_name(ingredient_name)
  exit 0 unless resolved

  process_ingredient(api_key, resolved, nutrition_data)
end
