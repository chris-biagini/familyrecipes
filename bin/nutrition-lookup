#!/usr/bin/env ruby
require 'bundler/setup'
require_relative '../lib/familyrecipes'
require 'net/http'
require 'json'
require 'open3'

PROJECT_ROOT = File.expand_path("..", __dir__)

# Load .env file if present (sets env vars like USDA_API_KEY)
dotenv_path = File.join(PROJECT_ROOT, ".env")
if File.exist?(dotenv_path)
  File.foreach(dotenv_path) do |line|
    line = line.strip
    next if line.empty? || line.start_with?('#')
    line = line.sub(/^export\s+/, '')
    key, value = line.split('=', 2)
    ENV[key] = value if key && value
  end
end

NUTRITION_PATH = File.join(PROJECT_ROOT, "resources/nutrition-data.yaml")
GROCERY_PATH = File.join(PROJECT_ROOT, "resources/grocery-info.yaml")
RECIPES_DIR = File.join(PROJECT_ROOT, "recipes")

API_KEY = ENV['USDA_API_KEY']
API_BASE = "https://api.nal.usda.gov/fdc/v1"

NUTRIENTS_OF_INTEREST = {
  1008 => :calories,  # Energy (kcal)
  1003 => :protein,   # Protein
  1004 => :fat,       # Total lipid (fat)
  1005 => :carbs,     # Carbohydrate, by difference
  1079 => :fiber,     # Fiber, total dietary
  1093 => :sodium     # Sodium, Na
}.freeze

# Units handled by NutritionCalculator::STANDARD_CONVERSIONS — never need
# per-ingredient portion entries.
STANDARD_UNITS = %w[oz lbs kg ml l g].freeze

# Maps USDA foodPortions modifier strings to our unit names.
PORTION_UNIT_PATTERNS = {
  /\bcup\b/i                       => 'cup',
  /\btablespoon\b|\btbsp\b/i      => 'Tbsp',
  /\bteaspoon\b|\btsp\b/i         => 'tsp',
  /\bstick\b/i                    => 'stick',
  /\blarge\b|\bmedium\b|\bwhole\b|\bfruit\b|\bitem\b/i => '~unitless'
}.freeze

AUTO_JSON_SCHEMA = {
  type: 'object',
  properties: {
    fdc_id: { type: 'integer' },
    reasoning: { type: 'string' },
    per_100g: {
      type: 'object',
      properties: {
        calories: { type: 'number' },
        protein: { type: 'number' },
        fat: { type: 'number' },
        carbs: { type: 'number' },
        fiber: { type: 'number' },
        sodium: { type: 'number' }
      },
      required: %w[calories protein fat carbs fiber sodium]
    },
    portions: {
      type: 'object',
      additionalProperties: { type: 'number' }
    },
    skip: { type: 'boolean' }
  },
  required: %w[reasoning]
}.freeze

def check_api_key!
  unless API_KEY && !API_KEY.empty?
    $stderr.puts "Error: USDA_API_KEY environment variable not set."
    $stderr.puts "Get a free API key at https://api.data.gov/signup/"
    $stderr.puts "Then: export USDA_API_KEY=your_key_here"
    exit 1
  end
end

def load_nutrition_data
  if File.exist?(NUTRITION_PATH)
    YAML.safe_load_file(NUTRITION_PATH, permitted_classes: [], permitted_symbols: [], aliases: false) || {}
  else
    {}
  end
end

def save_nutrition_data(data)
  File.write(NUTRITION_PATH, YAML.dump(data))
  puts "Saved to #{NUTRITION_PATH}"
end

def search_usda(query)
  uri = URI("#{API_BASE}/foods/search")
  uri.query = URI.encode_www_form(
    api_key: API_KEY,
    query: query,
    dataType: "Foundation,SR Legacy",
    pageSize: 10
  )

  response = Net::HTTP.get_response(uri)
  unless response.is_a?(Net::HTTPSuccess)
    $stderr.puts "API error: #{response.code} #{response.message}"
    return []
  end

  JSON.parse(response.body)['foods'] || []
end

def extract_nutrients(food)
  result = NUTRIENTS_OF_INTEREST.values.each_with_object({}) { |k, h| h[k] = 0 }
  (food['foodNutrients'] || []).each do |fn|
    nutrient_id = fn['nutrientId'] || fn.dig('nutrient', 'id')
    key = NUTRIENTS_OF_INTEREST[nutrient_id]
    result[key] = fn['value'] || fn['amount'] || 0 if key
  end
  result
end

def format_nutrients_preview(nutrients)
  "#{nutrients[:calories].round}cal | #{nutrients[:protein].round}g pro | #{nutrients[:fat].round}g fat | #{nutrients[:carbs].round}g carb | #{nutrients[:fiber].round}g fiber | #{nutrients[:sodium].round}mg Na"
end

def prompt_portions(api_portions = {})
  portions = {}

  # Show units that have API-sourced defaults
  units_to_prompt = api_portions.keys

  # Always offer cup/Tbsp/tsp if the API didn't find them — they're common enough
  %w[cup Tbsp tsp].each { |u| units_to_prompt << u unless units_to_prompt.include?(u) }

  puts "\nGram weights per unit (Enter accepts default, '-' skips, 'done' to finish):"
  puts "Units handled automatically: #{STANDARD_UNITS.join(', ')}"
  puts "~unitless = grams per count, for ingredients used without a unit (e.g. \"Eggs, 3\")"

  units_to_prompt.each do |unit|
    default = api_portions[unit]
    default_str = default ? " [#{default}]" : ""
    source = api_portions.key?(unit) ? " (USDA)" : ""
    print "  #{unit}#{default_str}#{source}: "
    input = $stdin.gets&.strip
    break if input&.downcase == 'done'
    next if input == '-'

    if input.nil? || input.empty?
      portions[unit] = default if default
    else
      value = Float(input) rescue nil
      portions[unit] = value if value
    end
  end

  print "  Additional unit (or Enter to finish): "
  loop do
    input = $stdin.gets&.strip
    break if input.nil? || input.empty?

    print "    grams per 1 #{input}: "
    value_str = $stdin.gets&.strip
    value = Float(value_str) rescue nil
    portions[input] = value if value

    print "  Additional unit (or Enter to finish): "
  end

  portions
end

def get_food_detail(fdc_id)
  uri = URI("#{API_BASE}/food/#{fdc_id}")
  uri.query = URI.encode_www_form(api_key: API_KEY)

  response = Net::HTTP.get_response(uri)
  unless response.is_a?(Net::HTTPSuccess)
    $stderr.puts "API error: #{response.code} #{response.message}"
    return nil
  end

  JSON.parse(response.body)
end

def parse_usda_portions(food_detail)
  portions = {}
  (food_detail['foodPortions'] || []).each do |fp|
    grams = fp['gramWeight']
    next unless grams && grams > 0

    modifier = fp['modifier'] || fp['portionDescription'] || fp['measureUnit']&.dig('name') || ''
    amount = fp['amount'] || 1.0

    PORTION_UNIT_PATTERNS.each do |pattern, unit|
      if modifier.match?(pattern)
        # Normalize to grams per 1 unit
        portions[unit] ||= (grams / amount).round(2)
        break
      end
    end
  end
  portions
end

def call_claude(prompt, model: 'haiku')
  cmd = [
    'claude', '-p', prompt,
    '--model', model,
    '--output-format', 'json',
    '--json-schema', JSON.generate(AUTO_JSON_SCHEMA),
    '--no-session-persistence',
    '--max-budget-usd', '0.05'
  ]

  # Strip CLAUDECODE env var so claude CLI doesn't refuse to run inside a session
  env = { 'CLAUDECODE' => nil }
  stdout, status = Open3.capture2(env, *cmd)
  unless status.success?
    $stderr.puts "Claude CLI error (exit #{status.exitstatus})"
    return nil
  end

  parsed = JSON.parse(stdout)
  # --output-format json wraps the response; structured_output has the schema-constrained data
  parsed['structured_output']
rescue JSON::ParserError => e
  $stderr.puts "Failed to parse Claude response: #{e.message}"
  nil
end

def build_claude_prompt(ingredient_name, foods_with_details)
  entries = foods_with_details.map.with_index do |(food, nutrients, api_portions), i|
    portions_str = if api_portions.any?
      "Portions: " + api_portions.map { |k, v| "#{k}=#{v}g" }.join(', ')
    else
      "Portions: none found"
    end

    data_type = food['dataType'] || 'Unknown'
    <<~ENTRY
      #{i + 1}. [#{data_type}] #{food['description']} (FDC #{food['fdcId']})
         #{format_nutrients_preview(nutrients)}
         #{portions_str}
    ENTRY
  end

  <<~PROMPT
    You are populating a nutrition database for a family recipe website.

    Ingredient name (as used in recipes): "#{ingredient_name}"

    USDA search results (nutrients are per 100g):

    #{entries.join("\n")}

    Pick the single best match for typical home cooking and return a JSON object.

    Guidelines:
    - Prefer "Foundation" data over "SR Legacy" when nutrition values are similar
    - Prefer whole/with skin/raw over processed unless the ingredient name suggests otherwise
    - Skip entries with obviously wrong data (e.g., 0 calories for a food that clearly has calories)
    - For portions, use USDA values when they seem reasonable; override from your world knowledge if not
    - Include ~unitless (grams per single item) only if the ingredient is commonly counted individually (eggs, lemons, apples — not flour, oil, sugar)
    - Include stick only for butter
    - Only include portion units that make practical sense for this specific ingredient
    - If none of the search results are a good match, return {"skip": true, "reasoning": "explanation"}
  PROMPT
end

def auto_lookup(ingredient_name, nutrition_data, model:)
  foods = search_usda(ingredient_name)
  if foods.empty?
    puts "  SKIP (no USDA results)"
    return nil
  end

  # Fetch detail (for portions) for top 5 results only
  foods_with_details = foods.first(5).map do |food|
    nutrients = extract_nutrients(food)
    detail = get_food_detail(food['fdcId'])
    api_portions = detail ? parse_usda_portions(detail) : {}
    [food, nutrients, api_portions]
  end

  prompt = build_claude_prompt(ingredient_name, foods_with_details)
  result = call_claude(prompt, model: model)

  unless result
    puts "  SKIP (Claude response error)"
    return nil
  end

  if result['skip']
    puts "  SKIP (#{result['reasoning']})"
    return nil
  end

  # Validate required fields
  unless result['fdc_id'] && result['per_100g']
    puts "  SKIP (malformed response: missing fdc_id or per_100g)"
    return nil
  end

  entry = {
    'fdc_id' => result['fdc_id'],
    'per_100g' => {
      'calories' => (result.dig('per_100g', 'calories') || 0).round(2),
      'protein' => (result.dig('per_100g', 'protein') || 0).round(2),
      'fat' => (result.dig('per_100g', 'fat') || 0).round(2),
      'carbs' => (result.dig('per_100g', 'carbs') || 0).round(2),
      'fiber' => (result.dig('per_100g', 'fiber') || 0).round(2),
      'sodium' => (result.dig('per_100g', 'sodium') || 0).round(2)
    }
  }

  portions = result['portions']
  entry['portions'] = portions if portions && !portions.empty?

  reasoning = result['reasoning'] || 'no reasoning given'
  cals = entry['per_100g']['calories']
  puts "  OK  FDC #{entry['fdc_id']} (#{cals}cal/100g) — #{reasoning}"

  nutrition_data[ingredient_name] = entry
  entry
end

def interactive_lookup(ingredient_name, nutrition_data)
  puts "\nSearching USDA for: \"#{ingredient_name}\"..."
  foods = search_usda(ingredient_name)

  if foods.empty?
    puts "No results found."
    return nil
  end

  puts "\nResults:"
  foods.each_with_index do |food, i|
    nutrients = extract_nutrients(food)
    data_type = food['dataType'] || 'Unknown'
    puts "  #{i + 1}. [#{data_type}] #{food['description']}"
    puts "     #{format_nutrients_preview(nutrients)}"
  end

  print "\nPick a number (or 's' to search again, 'q' to skip): "
  input = $stdin.gets&.strip
  return nil if input.nil? || input.downcase == 'q'

  if input.downcase == 's'
    print "New search query: "
    new_query = $stdin.gets&.strip
    return interactive_lookup(ingredient_name, nutrition_data) if new_query.nil? || new_query.empty?
    foods = search_usda(new_query)
    if foods.empty?
      puts "No results found."
      return nil
    end
    puts "\nResults:"
    foods.each_with_index do |food, i|
      nutrients = extract_nutrients(food)
      data_type = food['dataType'] || 'Unknown'
      puts "  #{i + 1}. [#{data_type}] #{food['description']}"
      puts "     #{format_nutrients_preview(nutrients)}"
    end
    print "\nPick a number (or 'q' to skip): "
    input = $stdin.gets&.strip
    return nil if input.nil? || input.downcase == 'q'
  end

  index = input.to_i - 1
  return nil if index < 0 || index >= foods.length

  food = foods[index]
  nutrients = extract_nutrients(food)
  fdc_id = food['fdcId']

  puts "\nSelected: #{food['description']} (FDC ID: #{fdc_id})"
  puts "Nutrients per 100g: #{format_nutrients_preview(nutrients)}"

  puts "\nFetching portion data from USDA..."
  food_detail = get_food_detail(fdc_id)
  api_portions = food_detail ? parse_usda_portions(food_detail) : {}

  if api_portions.any?
    puts "Found API portions: #{api_portions.map { |k, v| "#{k}=#{v}g" }.join(', ')}"
  else
    puts "No portion data found in API response."
  end

  portions = prompt_portions(api_portions)

  entry = {
    'fdc_id' => fdc_id,
    'per_100g' => {
      'calories' => nutrients[:calories].round(2),
      'protein' => nutrients[:protein].round(2),
      'fat' => nutrients[:fat].round(2),
      'carbs' => nutrients[:carbs].round(2),
      'fiber' => nutrients[:fiber].round(2),
      'sodium' => nutrients[:sodium].round(2)
    }
  }
  entry['portions'] = portions unless portions.empty?

  nutrition_data[ingredient_name] = entry
  puts "Added: #{ingredient_name}"
  entry
end

def find_missing_ingredients(nutrition_data)
  grocery_aisles = FamilyRecipes.parse_grocery_info(GROCERY_PATH)
  alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
  recipes = FamilyRecipes.parse_recipes(RECIPES_DIR)

  omit_set = Set.new
  if grocery_aisles["Omit_From_List"]
    grocery_aisles["Omit_From_List"].each do |item|
      omit_set << item[:name].downcase
      item[:aliases].each { |al| omit_set << al.downcase }
    end
  end

  all_ingredients = Set.new
  recipes.each do |recipe|
    recipe.all_ingredient_names(alias_map).each do |name|
      all_ingredients << name unless omit_set.include?(name.downcase)
    end
  end

  all_ingredients.select { |name| !nutrition_data.key?(name) }.sort
end

# --- Main ---

if ARGV.include?('--help') || ARGV.include?('-h')
  puts "Usage:"
  puts "  bin/nutrition-lookup \"Ingredient Name\"    Look up one ingredient interactively"
  puts "  bin/nutrition-lookup --missing              Find and fill unmapped ingredients interactively"
  puts "  bin/nutrition-lookup --auto                 Fill all missing ingredients using AI (Claude CLI)"
  puts "  bin/nutrition-lookup --auto --model sonnet  Use a specific Claude model (default: haiku)"
  puts ""
  puts "Requires USDA_API_KEY environment variable (free from https://api.data.gov/signup/)"
  puts "--auto mode also requires the Claude CLI (claude) to be installed and authenticated."
  exit 0
end

check_api_key!
nutrition_data = load_nutrition_data

if ARGV.include?('--auto')
  model_idx = ARGV.index('--model')
  model = model_idx ? ARGV[model_idx + 1] || 'haiku' : 'haiku'

  missing = find_missing_ingredients(nutrition_data)
  if missing.empty?
    puts "All ingredients are mapped!"
    exit 0
  end

  puts "#{missing.length} unmapped ingredients. Running auto-lookup with model: #{model}\n\n"

  added = 0
  skipped = 0
  missing.each_with_index do |name, i|
    puts "[#{i + 1}/#{missing.length}] #{name}"
    result = auto_lookup(name, nutrition_data, model: model)
    if result
      save_nutrition_data(nutrition_data)
      added += 1
    else
      skipped += 1
    end
  end

  puts "\nDone. Added #{added}/#{missing.length} ingredients. #{skipped} skipped."
  puts "Review: git diff resources/nutrition-data.yaml"
elsif ARGV.include?('--missing')
  missing = find_missing_ingredients(nutrition_data)

  if missing.empty?
    puts "All ingredients are mapped!"
    exit 0
  end

  puts "#{missing.length} unmapped ingredients:"
  missing.each_with_index { |name, i| puts "  #{i + 1}. #{name}" }

  print "\nLook up each interactively? (y/n): "
  input = $stdin.gets&.strip
  if input&.downcase == 'y'
    missing.each do |name|
      interactive_lookup(name, nutrition_data)
      save_nutrition_data(nutrition_data)
    end
  end
else
  ingredient_name = ARGV.reject { |a| a.start_with?('-') }.first

  unless ingredient_name
    $stderr.puts "Usage: bin/nutrition-lookup \"Ingredient Name\" or bin/nutrition-lookup --missing"
    exit 1
  end

  interactive_lookup(ingredient_name, nutrition_data)
  save_nutrition_data(nutrition_data)
end
