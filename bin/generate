#!/usr/bin/env ruby

# Load libraries and classes
require_relative '../lib/familyrecipes'

# Define project root as the current directory
project_root = File.expand_path("..", __dir__)

recipes_dir   = File.join(project_root, "recipes")
template_dir  = File.join(project_root, "templates/web")
resources_dir = File.join(project_root, "resources/web")
output_dir    = File.join(project_root, "output/web")
grocery_info_path = File.join(project_root, "resources/grocery-info.yaml")

# Parse grocery info and build alias map (must happen before recipe parsing)
print "Loading grocery info from #{grocery_info_path}..."
grocery_aisles = FamilyRecipes.parse_grocery_info(grocery_info_path)
alias_map = FamilyRecipes.build_alias_map(grocery_aisles)
known_ingredients = FamilyRecipes.build_known_ingredients(grocery_aisles, alias_map)

# Set the alias map on the Ingredient class for normalized_name lookups
Ingredient.alias_map = alias_map
print "done!\n"

# parse recipes; actual parsing happens in Recipe constructor
print "Parsing recipes from #{recipes_dir}..."

recipe_files = Dir.glob(File.join(recipes_dir, "**", "*")).select do |file|
  File.file?(file) && File.basename(file) != "Quick Bites.txt"
end

recipes_array = recipe_files.map do |file|
  source = File.read(file)
  id = FamilyRecipes.slugify(File.basename(file, ".*"))
  category = File.basename(File.dirname(file)).sub(/^./, &:upcase)

  Recipe.new(markdown_source: source, id: id, category: category)
end

file_path        = File.join(recipes_dir, "Quick Bites.txt")
base_category    = "Quick Bites"        # => "Quick Bites"
quick_bite_specs = []
current_subcat   = nil

File.foreach(file_path) do |line|
  case line
  when /^##\s+(.*)/
    # saw a subâ€‘heading like "## Snacks" or "## Mains"
    current_subcat = $1.strip
  when /^\s*-\s+(.*)/
    # saw an item line like "- Peanut Butter on Bread"
    text = $1.strip
    # build "Quick Bites: Snacks" (or just "Quick Bites" if no subcat yet)
    category = [base_category, current_subcat].compact.join(": ")
    quick_bite_specs << { text: text, category: category }
  end
end

quick_bites_array = quick_bite_specs.map do |spec|
  QuickBite.new(text_source: spec[:text], category: spec[:category])
end

print "done! (Parsed #{recipes_array.size} recipes and #{quick_bites_array.size} quick bites.)\n"  

# make output directory
FileUtils.mkdir_p(output_dir)

# write text and HTML files to output directory
print "Generating output files in #{output_dir}..."

recipes_array.each do |recipe|
  # Write text version
  text_path = File.join(output_dir, "#{recipe.id}.txt")
  FamilyRecipes.write_file_if_changed(text_path, recipe.source)
  
  # Write HTML version
  template_path = File.join(template_dir, "recipe-template.html.erb")
  html_path = File.join(output_dir, "#{recipe.id}.html")
  FamilyRecipes.write_file_if_changed(html_path, recipe.to_html(erb_template_path: template_path))
end

print "done!\n"

# Copy resources (e.g., stylesheets, javascript)
print "Copying web resources from #{resources_dir} to #{output_dir}..."
Dir.glob(File.join(resources_dir, '**', '*')).each do |source_file|
  next if File.directory?(source_file)

  # Get the relative path from the resources directory.
  relative_path = source_file.sub("#{resources_dir}/", '')

  # Special case: if the file is named 'htaccess', rename it to '.htaccess'
  if File.basename(source_file) == "htaccess"
    relative_path = File.join(File.dirname(relative_path), ".htaccess")
  end

  dest_file = File.join(output_dir, relative_path)

  if !File.exist?(dest_file) || !FileUtils.identical?(source_file, dest_file)
    FileUtils.mkdir_p(File.dirname(dest_file))
    FileUtils.cp(source_file, dest_file)
    puts "Copied: #{relative_path}"
  end
end
print "done!\n"

# build home page
print "Generating homepage in #{output_dir}..."

recipes_by_category = recipes_array.group_by(&:category) # hash of recipes, with categories as keys
quick_bites_by_category = quick_bites_array.group_by(&:category) # hash of quick bites, with categories as keys

# Read and process the template
template_path = File.join(template_dir, "homepage-template.html.erb")
erb_template = ERB.new(File.read(template_path), trim_mode: "-")

# Generate the homepage file
homepage_path = File.join(output_dir, "index.html")
FamilyRecipes.write_file_if_changed(homepage_path, erb_template.result_with_hash(grouped_recipes: recipes_by_category))

print "done!\n"

# Generate index
print "Generating index..."

recipes_by_ingredient = Hash.new { |hash, key| hash[key] = [] } # hash of recipes, with ingredients as keys
recipes_array.each do |recipe|
    recipe.all_ingredients.each do |ingredient|
      recipes_by_ingredient[ingredient.normalized_name] << recipe
    end
end
sorted_ingredients = recipes_by_ingredient.sort_by { |ingredient_name, _| ingredient_name.downcase }

template_path = File.join(template_dir, "index-template.html.erb")
erb_template = ERB.new(File.read(template_path), trim_mode: "-")
index_path = File.join(output_dir, "index", "index.html")
FileUtils.mkdir_p(File.dirname(index_path))  # Ensure directory exists
FamilyRecipes.write_file_if_changed(index_path, erb_template.result_with_hash(sorted_ingredients: sorted_ingredients))

print "done!\n"

# Validate ingredients
print "Validating ingredients..."
ingredients_to_recipes = Hash.new { |h, k| h[k] = [] }
recipes_array.each do |recipe|
  recipe.all_ingredients.each do |ingredient|
    ingredients_to_recipes[ingredient.name] << recipe.title
  end
end
quick_bites_array.each do |quick_bite|
  quick_bite.ingredients.each do |ingredient_name|
    ingredients_to_recipes[ingredient_name] << quick_bite.title
  end
end

unknown_ingredients = ingredients_to_recipes.keys.to_set - known_ingredients
if unknown_ingredients.any?
  puts "\n"
  puts "WARNING: The following ingredients are not in grocery-info.yaml:"
  unknown_ingredients.sort.each do |ing|
    recipes = ingredients_to_recipes[ing].uniq.sort
    puts "  - #{ing} (in: #{recipes.join(', ')})"
  end
  puts "Add them to grocery-info.yaml or add as aliases to existing items."
  puts ""
else
  print "done! (All ingredients validated.)\n"
end

# Build grocery page
print "Generating groceries page..."
grocery_info = {}
grocery_aisles.each do |aisle, items|
  grocery_info[aisle] = items.map do |item|
    { name: item[:name], staple: item[:staple] }
  end
end

combined_recipes_and_quick_bites_by_category = recipes_by_category.merge(quick_bites_by_category)

# Separate regular recipes from Quick Bites for the grocery page layout
grocery_regular_recipes = combined_recipes_and_quick_bites_by_category.reject { |cat, _| cat.start_with?('Quick Bites') }
grocery_quick_bites = combined_recipes_and_quick_bites_by_category.select { |cat, _| cat.start_with?('Quick Bites') }

# Extract subsection names from Quick Bites categories (e.g., "Quick Bites: Snacks" -> "Snacks")
grocery_quick_bites_by_subsection = grocery_quick_bites.transform_keys do |cat|
  name = cat.sub(/^Quick Bites(: )?/, '')
  name.empty? ? 'Other' : name
end

template_path = File.join(template_dir, "groceries-template.html.erb")
erb_template = ERB.new(File.read(template_path), trim_mode: "-")
groceries_path = File.join(output_dir, "groceries", "index.html")
FileUtils.mkdir_p(File.dirname(groceries_path))  # Ensure directory exists
FamilyRecipes.write_file_if_changed(groceries_path, erb_template.result_with_hash(
  regular_recipes: grocery_regular_recipes,
  quick_bites_by_subsection: grocery_quick_bites_by_subsection,
  ingredient_database: grocery_info
))
print "done!\n"
