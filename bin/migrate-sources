#!/usr/bin/env ruby
# frozen_string_literal: true

# One-time migration: converts flat `source` strings in nutrition-data.yaml
# to structured `sources` arrays with type/provenance metadata.
#
# USDA entries get their description fetched from the FDC API.
# Label entries become { type: label, product: "..." }.
#
# Idempotent — entries that already have a `sources` key are skipped.

require 'bundler/setup'
require 'net/http'
require 'json'
require 'yaml'

PROJECT_ROOT = File.expand_path('..', __dir__)
NUTRITION_PATH = File.join(PROJECT_ROOT, 'resources/nutrition-data.yaml')
USDA_PATTERN = /USDA SR Legacy \(FDC (\d+)\)/

# --- Data I/O (mirrors bin/nutrition) ---

def load_nutrition_data
  return {} unless File.exist?(NUTRITION_PATH)

  YAML.safe_load_file(NUTRITION_PATH, permitted_classes: [], permitted_symbols: [], aliases: false) || {}
end

def save_nutrition_data(data)
  sorted = data.sort_by { |k, _| k.downcase }.to_h

  sorted.each_value do |entry|
    round_nutrients(entry)
    round_portions(entry)
    round_density(entry)
  end

  File.write(NUTRITION_PATH, YAML.dump(sorted))
end

def round_nutrients(entry)
  return unless entry['nutrients'].is_a?(Hash)

  entry['nutrients'].transform_values! { |v| v.is_a?(Float) ? v.round(4) : v }
end

def round_portions(entry)
  return unless entry['portions'].is_a?(Hash)

  entry['portions'].transform_values! { |v| v.is_a?(Float) ? v.round(2) : v }
end

def round_density(entry)
  return unless entry['density'].is_a?(Hash)

  entry['density']['grams'] = entry['density']['grams'].round(2) if entry['density']['grams'].is_a?(Float)
  entry['density']['volume'] = entry['density']['volume'].round(4) if entry['density']['volume'].is_a?(Float)
end

# --- API key ---

def load_api_key
  return ENV['USDA_API_KEY'] if ENV['USDA_API_KEY']

  env_path = File.join(PROJECT_ROOT, '.env')
  return nil unless File.exist?(env_path)

  File.readlines(env_path).each do |line|
    key, value = line.strip.split('=', 2)
    return value if key == 'USDA_API_KEY' && value && !value.empty?
  end
  nil
end

# --- USDA API ---

def fetch_food_detail(api_key, fdc_id)
  uri = URI("https://api.nal.usda.gov/fdc/v1/food/#{fdc_id}")
  request = Net::HTTP::Get.new(uri)
  request['X-Api-Key'] = api_key

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
  JSON.parse(response.body)
rescue StandardError => error # rubocop:disable Naming/RescuedExceptionsVariableName
  warn "  API error for FDC #{fdc_id}: #{error.message}"
  nil
end

# --- Source builders ---

def build_usda_source(fdc_id, food_detail)
  source = { 'type' => 'usda', 'dataset' => food_detail['dataType'], 'fdc_id' => fdc_id }
  source['description'] = food_detail['description'] if food_detail['description']
  source
end

def build_usda_source_without_description(fdc_id)
  { 'type' => 'usda', 'dataset' => 'SR Legacy', 'fdc_id' => fdc_id }
end

def build_label_source(product)
  { 'type' => 'label', 'product' => product }
end

# --- Migration logic ---

def migrate_entry(name, entry, api_key)
  return :skip if entry.key?('sources')
  return :no_source unless entry.key?('source')

  old_source = entry['source']
  match = old_source.match(USDA_PATTERN)

  new_source = if match
                 migrate_usda_source(name, match[1].to_i, api_key)
               else
                 puts "  #{name}: label -> #{old_source}"
                 build_label_source(old_source)
               end

  entry['sources'] = [new_source]
  entry.delete('source')
  :migrated
end

def migrate_usda_source(name, fdc_id, api_key)
  food_detail = fetch_food_detail(api_key, fdc_id)

  if food_detail
    puts "  #{name}: USDA FDC #{fdc_id} -> #{food_detail['description']}"
    build_usda_source(fdc_id, food_detail)
  else
    warn "  #{name}: USDA FDC #{fdc_id} (no description — API failed)"
    build_usda_source_without_description(fdc_id)
  end
end

# --- Main ---

api_key = load_api_key

unless api_key
  warn 'USDA_API_KEY not found. Set it in .env or environment.'
  warn 'Needed to fetch descriptions for USDA entries.'
  exit 1
end

nutrition_data = load_nutrition_data
puts "Loaded #{nutrition_data.size} entries from #{NUTRITION_PATH}\n\n"

counts = { migrated: 0, skipped: 0, no_source: 0 }
usda_call_count = 0

nutrition_data.each do |name, entry|
  is_usda = entry['source']&.match?(USDA_PATTERN)

  result = migrate_entry(name, entry, api_key)
  counts[result] += 1

  next unless result == :migrated && is_usda

  usda_call_count += 1
  sleep 0.25
end

puts "\nMigrated #{counts[:migrated]}, skipped #{counts[:skipped]} (already done), " \
     "#{counts[:no_source]} without source."
puts "Made #{usda_call_count} USDA API calls."

save_nutrition_data(nutrition_data)
puts "Saved to #{NUTRITION_PATH}"
