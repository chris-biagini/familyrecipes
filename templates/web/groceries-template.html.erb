<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Grocery List</title>
	<link rel="stylesheet" href="/style.css">
	<style>
		/* Example print stylesheet: when printing, only show the grocery list */
		@media print {
			body * {
				visibility: hidden;
			}
			#grocery-list, #grocery-list * {
				visibility: visible;
			}
			#grocery-list {
				position: absolute;
				left: 0;
				top: 0;
			}
		}
	</style>
</head>
<body>
	<nav>
		<div>
			<a href="/" class="home" title="Home (Table of Contents)">Home</a>
			<a href="/index/" class="index" title="Index of ingredients">Index</a>
			<a href="/groceries/" class="groceries" title="Printable grocery list">Groceries</a>
		</div>
	</nav>
	
	<main>
		<article>
			<header>
				<h1>Grocery List</h1>
			</header>
			
			<!-- Loop over recipes by category -->
			<%- grouped_recipes.each do |category, recipes| -%>
			<section>
				<h2><%= category %></h2>
				<ul>
					<%- recipes.each do |recipe| -%>
					<li>
						<!--
							We add a data attribute holding a JSON array of ingredient objects.
							Each ingredient object includes a normalized name and its quantity, split into a value and a unit.
						-->
						<input type="checkbox" id="recipe-<%= recipe.id %>" data-ingredients='<%= recipe.all_ingredients.map { |ing| { 
							name: ing.normalized_name, 
							value: (ing.quantity_value || "").to_s, 
							unit: (ing.quantity_unit || "").to_s 
						} }.to_json %>'>
						<label for="recipe-<%= recipe.id %>"><%= recipe.title %></label>
					</li>
					<%- end -%>
				</ul>
			</section>
			<%- end -%>
			
		</article>
		
		<!-- This div will be updated dynamically with the aggregated grocery list -->
		<div id="grocery-list">
			<h2>Your Grocery List</h2>
			<ul></ul>
		</div>
		
	</main>
	
<script>
	// Update the grocery list by aggregating ingredients with separated value/unit pairs.
	function updateGroceryList() {
		const aggregatedIngredients = {};

		// Loop over all checked recipe checkboxes.
		document.querySelectorAll('input[type="checkbox"]:checked').forEach(function(checkbox) {
			let ingredients;
			try {
				ingredients = JSON.parse(checkbox.dataset.ingredients);
			} catch (e) {
				console.error("Error parsing ingredients for checkbox", checkbox, e);
				return;
			}

			// For each ingredient, aggregate by name and then by unit.
			ingredients.forEach(function(ing) {
				const name  = ing.name;
				const value = ing.value ? ing.value.toString().trim() : "";
				const unit  = ing.unit ? ing.unit.toString().trim() : "";

				if (!aggregatedIngredients[name]) {
					aggregatedIngredients[name] = {};
				}
				// Use the unit (empty string for unspecified) as the key.
				if (!aggregatedIngredients[name][unit]) {
					aggregatedIngredients[name][unit] = [];
				}
				aggregatedIngredients[name][unit].push(value);
			});
		});

		// Helper: Format the aggregated quantities for one ingredient.
		// Returns an array of strings to be joined later.
		function formatAggregatedQuantity(quantitiesByUnit) {
			const pieces = [];
			
			// Process specified units (non-empty keys).
			for (const unit in quantitiesByUnit) {
				if (unit !== "") {
					const values = quantitiesByUnit[unit];
					// Check if all values are pure numbers.
					const allNumeric = values.every(v => v !== "" && !isNaN(parseFloat(v)) && parseFloat(v).toString() === v);
					if (allNumeric) {
						// Sum the numeric values.
						const sum = values.reduce((acc, v) => acc + parseFloat(v), 0);
						pieces.push(`${sum} ${unit}`);
					} else {
						// Otherwise, join unique values with commas.
						const uniqueValues = Array.from(new Set(values));
						pieces.push(uniqueValues.join(", "));
					}
				}
			}
			
			// Process unspecified quantities (empty unit).
			if (quantitiesByUnit[""]) {
				const unspecifiedValues = quantitiesByUnit[""];
				const hasSpecified = Object.keys(quantitiesByUnit).some(key => key !== "");
				if (hasSpecified) {
					// If there's also a specified quantity, indicate additional amounts.
					pieces.push("plus additional");
				} else {
					// Only unspecified quantities exist.
					// Filter out empty values.
					const nonEmpty = unspecifiedValues.filter(v => v !== "");
					if (nonEmpty.length > 0) {
						const allNumeric = nonEmpty.every(v => !isNaN(parseFloat(v)) && parseFloat(v).toString() === v);
						if (allNumeric) {
							const sum = nonEmpty.reduce((acc, v) => acc + parseFloat(v), 0);
							pieces.push(`${sum}`);
						} else {
							const uniqueValues = Array.from(new Set(nonEmpty));
							pieces.push(uniqueValues.join(", "));
						}
					}
				}
			}
			
			return pieces;
		}

		// Update the grocery list <ul> with aggregated ingredients.
		const groceryListUl = document.querySelector('#grocery-list ul');
		groceryListUl.innerHTML = '';  // Clear previous content

		// Sort ingredients alphabetically by name.
		const sortedNames = Object.keys(aggregatedIngredients).sort();
		sortedNames.forEach(function(name) {
			const quantitiesByUnit = aggregatedIngredients[name];
			const pieces = formatAggregatedQuantity(quantitiesByUnit);
			let displayText = name;
			// Only add a parenthetical if there's at least one non-empty quantity.
			if (pieces.length > 0) {
				displayText += " (" + pieces.join(", ") + ")";
			}
			const li = document.createElement('li');
			li.textContent = displayText;
			groceryListUl.appendChild(li);
		});
	}

	// Attach event listeners to recipe checkboxes.
	document.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
		cb.addEventListener('change', updateGroceryList);
	});

	// Update the list on page load (in case any boxes are pre-checked).
	updateGroceryList();
</script>
	
	<!-- <script src="script.js" defer></script> -->
</body>
</html>