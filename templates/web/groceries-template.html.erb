<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Grocery List</title>
	<link rel="stylesheet" href="/style.css">
	<style>
		/* Example print stylesheet: when printing, only show the grocery list */
		@media print {
			body * {
				visibility: hidden;
			}
			#grocery-list, #grocery-list * {
				visibility: visible;
			}
			#grocery-list {
				position: absolute;
				left: 0;
				top: 0;
			}
		}
	</style>
</head>
<body>
	<nav>
		<div>
			<a href="/" class="home" title="Home (Table of Contents)">Home</a>
			<a href="/index/" class="index" title="Index of ingredients">Index</a>
			<a href="/groceries/" class="groceries" title="Printable grocery list">Groceries</a>
		</div>
		
		<div>
			<a href="#" onclick="window.print(); return false;" class="print">Print</a>
		</div>
	</nav>
	
	<main>
		<article>
			<header>
				<h1>Grocery List</h1>
			</header>
			
			<!-- Loop over recipes by category -->
			<%- grouped_recipes.each do |category, recipes| -%>
			<section>
				<h2><%= category %></h2>
				<ul>
					<%- recipes.each do |recipe| -%>
					<li>
						<input type="checkbox" id="recipe-<%= recipe.id %>" data-ingredients='<%= recipe.all_ingredients.map { |ing| { 
							name: ing.normalized_name, 
							value: (ing.quantity_value || "").to_s, 
							unit: (ing.quantity_unit || "").to_s 
						} }.to_json %>'>
						<label for="recipe-<%= recipe.id %>"><%= recipe.title %></label>
					</li>
					<%- end -%>
				</ul>
			</section>
			<%- end -%>
			
		</article>
		
		<!-- This div will be updated dynamically with the aggregated grocery list -->
		<div id="grocery-list">
			<h2>Your Grocery List</h2>
			<!-- Weâ€™ll insert the grouped list here -->
			<div id="grocery-list-content"></div>
		</div>
		
	</main>
	
	<!-- Embed ingredient database JSON for use in JavaScript -->
	<script id="ingredient-db" type="application/json">
		<%= ingredient_db.to_json %>
	</script>
	
	<script>
		// Update the grocery list by aggregating ingredients, grouping by aisle, and including staples.
		function updateGroceryList() {
			// Parse the ingredient DB from the embedded JSON.
			const ingredientDB = JSON.parse(document.getElementById('ingredient-db').textContent);
			
			const aggregatedIngredients = {};

			// Loop over all checked recipe checkboxes.
			document.querySelectorAll('input[type="checkbox"]:checked').forEach(function(checkbox) {
				let ingredients;
				try {
					ingredients = JSON.parse(checkbox.dataset.ingredients);
				} catch (e) {
					console.error("Error parsing ingredients for checkbox", checkbox, e);
					return;
				}

				// Aggregate each ingredient by name and then by unit.
				ingredients.forEach(function(ing) {
					const name  = ing.name;
					const value = ing.value ? ing.value.toString().trim() : "";
					const unit  = ing.unit ? ing.unit.toString().trim() : "";

					if (!aggregatedIngredients[name]) {
						aggregatedIngredients[name] = {};
					}
					// Use the unit (empty string for unspecified) as the key.
					if (!aggregatedIngredients[name][unit]) {
						aggregatedIngredients[name][unit] = [];
					}
					aggregatedIngredients[name][unit].push(value);
				});
			});

// Include staple ingredients even if not selected.
			Object.entries(ingredientDB).forEach(([dbName, details]) => {
					if (details.is_staple) {
							// Look for an existing aggregated ingredient matching this staple (case-insensitive)
							let matchingKey = Object.keys(aggregatedIngredients).find(
									aggName => aggName.toLowerCase() === dbName.toLowerCase()
							);
							if (matchingKey) {
									// If there is any specified quantity (i.e. any key other than "")
									const specifiedKeys = Object.keys(aggregatedIngredients[matchingKey]).filter(key => key !== "");
									if (specifiedKeys.length > 0) {
											// Ensure the unspecified group exists, then push a marker.
											if (!aggregatedIngredients[matchingKey].hasOwnProperty("")) {
													aggregatedIngredients[matchingKey][""] = [];
											}
											aggregatedIngredients[matchingKey][""].push("staple-marker");
									}
							} else {
									// If not present at all, add it as a staple (with no unspecified marker).
									aggregatedIngredients[dbName] = { "": [] };
							}
					}
			});

			// Helper: Format aggregated quantities.
			function formatAggregatedQuantity(quantitiesByUnit) {
				const pieces = [];
				
				// Process specified units.
				for (const unit in quantitiesByUnit) {
					if (unit !== "") {
						const values = quantitiesByUnit[unit];
						const allNumeric = values.every(v => v !== "" && !isNaN(parseFloat(v)) && parseFloat(v).toString() === v);
						if (allNumeric) {
							const sum = values.reduce((acc, v) => acc + parseFloat(v), 0);
							pieces.push(`${sum} ${unit}`);
						} else {
							const uniqueValues = Array.from(new Set(values));
							pieces.push(uniqueValues.join(", "));
						}
					}
				}
				
				// Process unspecified quantities.
				if (quantitiesByUnit[""]) {
					const unspecifiedValues = quantitiesByUnit[""];
					const hasSpecified = Object.keys(quantitiesByUnit).some(key => key !== "");
					if (hasSpecified) {
						pieces.push("plus additional");
					} else {
						const nonEmpty = unspecifiedValues.filter(v => v !== "");
						if (nonEmpty.length > 0) {
							const allNumeric = nonEmpty.every(v => !isNaN(parseFloat(v)) && parseFloat(v).toString() === v);
							if (allNumeric) {
								const sum = nonEmpty.reduce((acc, v) => acc + parseFloat(v), 0);
								pieces.push(`${sum}`);
							} else {
								const uniqueValues = Array.from(new Set(nonEmpty));
								pieces.push(uniqueValues.join(", "));
							}
						}
					}
				}
				
				return pieces;
			}

			// Function to determine the aisle for a given ingredient using the DB.
			function getAisle(name) {
				const lowerName = name.toLowerCase();
				for (const [dbName, details] of Object.entries(ingredientDB)) {
					if (dbName.toLowerCase() === lowerName) {
						return details.aisle;
					}
					if (details.aliases && Array.isArray(details.aliases)) {
						for (const alias of details.aliases) {
							if (alias.toLowerCase() === lowerName) {
								return details.aisle;
							}
						}
					}
				}
				return "Miscellaneous";
			}

			// Group aggregated ingredients by aisle.
			const groupedByAisle = {};
			Object.keys(aggregatedIngredients).forEach(function(name) {
				const aisle = getAisle(name);
				if (!groupedByAisle[aisle]) {
					groupedByAisle[aisle] = {};
				}
				groupedByAisle[aisle][name] = aggregatedIngredients[name];
			});

			// Update the DOM with the grouped grocery list.
			const groceryListContainer = document.getElementById('grocery-list-content');
			groceryListContainer.innerHTML = '';  // Clear previous content

			const sortedAisles = Object.keys(groupedByAisle).sort();
			sortedAisles.forEach(function(aisle) {
				const aisleHeader = document.createElement('h3');
				aisleHeader.textContent = aisle;
				groceryListContainer.appendChild(aisleHeader);

				const ul = document.createElement('ul');
				const ingredientNames = Object.keys(groupedByAisle[aisle]).sort();
				ingredientNames.forEach(function(name) {
					const quantitiesByUnit = groupedByAisle[aisle][name];
					const pieces = formatAggregatedQuantity(quantitiesByUnit);
					let displayText = name;
					if (pieces.length > 0) {
						displayText += " (" + pieces.join(", ") + ")";
					}
					const li = document.createElement('li');
					li.textContent = displayText;
					ul.appendChild(li);
				});
				groceryListContainer.appendChild(ul);
			});
		}

		// Attach event listeners to recipe checkboxes.
		document.querySelectorAll('input[type="checkbox"]').forEach(function(cb) {
			cb.addEventListener('change', updateGroceryList);
		});

		// Update the list on page load.
		updateGroceryList();
	</script>
</body>
</html>