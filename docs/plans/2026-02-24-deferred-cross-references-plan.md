# Deferred Cross-Reference Resolution — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers-extended-cc:executing-plans to implement this plan task-by-task.

**Goal:** Fix issue #91 — cross-references are never silently dropped. Unresolved refs are persisted and resolved when targets become available.

**Architecture:** Add `target_slug` and `target_title` columns to `cross_references`, make `target_recipe_id` nullable. MarkdownImporter always creates cross-references regardless of whether the target exists. A `resolve_pending` class method on CrossReference resolves deferred refs. Views render unresolved refs as plain text.

**Tech Stack:** Rails 8, SQLite, Minitest

---

### Task 0: Migration — add columns and make FK nullable

**Files:**
- Create: `db/migrate/004_add_deferred_cross_reference_columns.rb`
- Modify: `db/schema.rb` (auto-generated by migration)

**Step 1: Write the migration**

```ruby
# frozen_string_literal: true

class AddDeferredCrossReferenceColumns < ActiveRecord::Migration[8.1]
  def change
    change_column_null :cross_references, :target_recipe_id, true

    add_column :cross_references, :target_slug, :string
    add_column :cross_references, :target_title, :string

    # Backfill from existing resolved references
    reversible do |dir|
      dir.up do
        execute <<~SQL
          UPDATE cross_references
          SET target_slug = (SELECT slug FROM recipes WHERE recipes.id = cross_references.target_recipe_id),
              target_title = (SELECT title FROM recipes WHERE recipes.id = cross_references.target_recipe_id)
          WHERE target_recipe_id IS NOT NULL
        SQL
      end
    end

    change_column_null :cross_references, :target_slug, false
    change_column_null :cross_references, :target_title, false
  end
end
```

**Step 2: Run the migration**

Run: `rails db:migrate`
Expected: Migration applies cleanly. `db/schema.rb` shows new columns on `cross_references`.

**Step 3: Verify schema**

Run: `rails db:migrate:status`
Expected: Migration 004 shows `up`.

**Step 4: Commit**

```bash
git add db/migrate/004_add_deferred_cross_reference_columns.rb db/schema.rb
git commit -m "feat: add target_slug/target_title columns to cross_references (#91)"
```

---

### Task 1: CrossReference model — optional FK, scopes, resolve_pending

**Files:**
- Modify: `app/models/cross_reference.rb`
- Modify: `test/models/cross_reference_test.rb`

**Step 1: Write the failing tests**

Add these tests to `test/models/cross_reference_test.rb`, inside the existing `CrossReferenceModelTest` class:

```ruby
test 'allows nil target_recipe when target_slug and target_title are present' do
  cross_ref = CrossReference.create!(
    step: @step, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert cross_ref.persisted?
  assert_nil cross_ref.target_recipe_id
end

test 'requires target_slug' do
  cross_ref = CrossReference.new(step: @step, position: 1, target_title: 'Poolish')

  assert_not cross_ref.valid?
  assert_includes cross_ref.errors[:target_slug], "can't be blank"
end

test 'requires target_title' do
  cross_ref = CrossReference.new(step: @step, position: 1, target_slug: 'poolish')

  assert_not cross_ref.valid?
  assert_includes cross_ref.errors[:target_title], "can't be blank"
end

test 'resolved? returns true when target_recipe is set' do
  cross_ref = CrossReference.new(
    step: @step, target_recipe: @target_recipe, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert_predicate cross_ref, :resolved?
end

test 'pending? returns true when target_recipe is nil' do
  cross_ref = CrossReference.new(
    step: @step, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert_predicate cross_ref, :pending?
end

test 'pending scope returns only unresolved references' do
  CrossReference.create!(
    step: @step, target_recipe: @target_recipe, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )
  CrossReference.create!(
    step: @step, position: 2,
    target_slug: 'nonexistent', target_title: 'Nonexistent'
  )

  assert_equal 1, CrossReference.pending.count
  assert_equal 'nonexistent', CrossReference.pending.first.target_slug
end

test 'resolve_pending links pending refs to matching recipes' do
  CrossReference.create!(
    step: @step, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  CrossReference.resolve_pending(kitchen: @kitchen)

  ref = CrossReference.find_by(target_slug: 'poolish')

  assert_equal @target_recipe.id, ref.target_recipe_id
end

test 'resolve_pending skips refs whose target does not exist' do
  CrossReference.create!(
    step: @step, position: 1,
    target_slug: 'nonexistent', target_title: 'Nonexistent'
  )

  CrossReference.resolve_pending(kitchen: @kitchen)

  ref = CrossReference.find_by(target_slug: 'nonexistent')

  assert_nil ref.target_recipe_id
end
```

**Step 2: Run tests to verify they fail**

Run: `ruby -Itest test/models/cross_reference_test.rb`
Expected: New tests fail (validations not yet present, scopes not defined, etc.)

**Step 3: Update the model**

Replace the contents of `app/models/cross_reference.rb`:

```ruby
# frozen_string_literal: true

class CrossReference < ApplicationRecord
  acts_as_tenant :kitchen

  belongs_to :step, inverse_of: :cross_references
  belongs_to :target_recipe, class_name: 'Recipe', optional: true

  validates :position, presence: true, uniqueness: { scope: :step_id }
  validates :target_slug, presence: true
  validates :target_title, presence: true

  scope :pending, -> { where(target_recipe_id: nil) }
  scope :resolved, -> { where.not(target_recipe_id: nil) }

  def resolved? = target_recipe_id.present?
  def pending?  = !resolved?

  def self.resolve_pending(kitchen:)
    slugs = pending.distinct.pluck(:target_slug)
    return if slugs.empty?

    slug_to_id = kitchen.recipes.where(slug: slugs).pluck(:slug, :id).to_h
    return if slug_to_id.empty?

    pending.where(target_slug: slug_to_id.keys).find_each do |ref|
      ref.update_column(:target_recipe_id, slug_to_id.fetch(ref.target_slug))
    end
  end
end
```

**Step 4: Update existing tests that check for required target_recipe**

In `test/models/cross_reference_test.rb`, find the test `'requires target_recipe'` and replace it:

```ruby
test 'allows nil target_recipe (deferred resolution)' do
  cross_ref = CrossReference.new(
    step: @step, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert cross_ref.valid?
end
```

Also update the test `'delegates target_slug to target_recipe'` and `'delegates target_title to target_recipe'` — these should now test column accessors rather than delegates:

```ruby
test 'target_slug returns stored column value' do
  cross_ref = CrossReference.new(
    step: @step, target_recipe: @target_recipe, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert_equal 'poolish', cross_ref.target_slug
end

test 'target_title returns stored column value' do
  cross_ref = CrossReference.new(
    step: @step, target_recipe: @target_recipe, position: 1,
    target_slug: 'poolish', target_title: 'Poolish'
  )

  assert_equal 'Poolish', cross_ref.target_title
end
```

Also update ALL existing test code that creates CrossReference records to include `target_slug:` and `target_title:`. This includes tests in `cross_reference_test.rb` (both `CrossReferenceModelTest` and `StepIngredientListItemsTest`).

For `CrossReferenceModelTest`, every `CrossReference.new` or `CrossReference.create!` that sets `target_recipe: @target_recipe` should also set `target_slug: 'poolish', target_title: 'Poolish'`.

For `StepIngredientListItemsTest`, every `CrossReference.create!` that sets `target_recipe: @target` should also set `target_slug: 'poolish', target_title: 'Poolish'`.

**Step 5: Run all tests**

Run: `ruby -Itest test/models/cross_reference_test.rb`
Expected: All tests pass.

**Step 6: Commit**

```bash
git add app/models/cross_reference.rb test/models/cross_reference_test.rb
git commit -m "feat: CrossReference supports deferred resolution (#91)

Optional target_recipe FK, pending/resolved scopes, resolve_pending
class method. Existing delegate replaced by column accessors."
```

---

### Task 2: MarkdownImporter — always persist cross-references

**Files:**
- Modify: `app/services/markdown_importer.rb:14-17` (import method)
- Modify: `app/services/markdown_importer.rb:126-137` (import_cross_reference method)
- Modify: `test/services/markdown_importer_test.rb`

**Step 1: Write the failing test**

Add to `test/services/markdown_importer_test.rb`:

```ruby
test 'creates pending cross-reference when target recipe does not exist' do
  markdown = <<~MARKDOWN
    # Pasta

    Category: Main

    ## Cook (boil it)

    - @[Nonexistent Sauce]
    - Spaghetti, 1 lb

    Cook and serve.
  MARKDOWN

  recipe = MarkdownImporter.import(markdown, kitchen: @kitchen)
  ref = recipe.cross_references.first

  assert_equal 1, recipe.cross_references.count
  assert_equal 'nonexistent-sauce', ref.target_slug
  assert_equal 'Nonexistent Sauce', ref.target_title
  assert_nil ref.target_recipe_id
  assert_predicate ref, :pending?
end

test 'resolves pending cross-references when target is imported later' do
  # Import recipe with unresolved reference first
  pasta_md = <<~MARKDOWN
    # Pasta

    Category: Main

    ## Cook (boil it)

    - @[Marinara Sauce]
    - Spaghetti, 1 lb

    Cook and serve.
  MARKDOWN

  sauce_md = <<~MARKDOWN
    # Marinara Sauce

    Category: Sauce

    ## Cook (simmer)

    - Tomatoes, 1 can

    Simmer for 30 minutes.
  MARKDOWN

  pasta = MarkdownImporter.import(pasta_md, kitchen: @kitchen)

  assert_predicate pasta.cross_references.first, :pending?

  # Now import the target recipe — resolve_pending runs after import
  sauce = MarkdownImporter.import(sauce_md, kitchen: @kitchen)

  pasta.cross_references.first.reload

  assert_predicate pasta.cross_references.first, :resolved?
  assert_equal sauce.id, pasta.cross_references.first.target_recipe_id
end
```

**Step 2: Run tests to verify they fail**

Run: `ruby -Itest test/services/markdown_importer_test.rb -n /pending/`
Expected: Both new tests fail.

**Step 3: Update import_cross_reference**

In `app/services/markdown_importer.rb`, replace `import_cross_reference` (lines 126-137):

```ruby
def import_cross_reference(step, data, position)
  target_slug = FamilyRecipes.slugify(data[:target_title])
  target = kitchen.recipes.find_by(slug: target_slug)

  step.cross_references.create!(
    target_recipe: target,
    target_slug: target_slug,
    target_title: data[:target_title],
    multiplier: data[:multiplier] || 1.0,
    prep_note: data[:prep_note],
    position: position
  )
end
```

**Step 4: Add resolve_pending call to import method**

In `app/services/markdown_importer.rb`, replace the `import` method (lines 14-18):

```ruby
def import
  recipe = save_recipe
  CrossReference.resolve_pending(kitchen: kitchen)
  compute_nutrition(recipe)
  recipe
end
```

**Step 5: Update the existing test that expects zero cross-references for missing targets**

Find the test `'cross-references are not created when target recipe is missing'` in `test/services/markdown_importer_test.rb` and replace it:

```ruby
test 'creates pending cross-reference when target recipe is missing' do
  markdown_with_missing_ref = <<~MARKDOWN
    # Pasta

    Category: Main

    ## Cook (boil it)

    - @[Nonexistent Sauce]
    - Spaghetti, 1 lb

    Cook and serve.
  MARKDOWN

  recipe = MarkdownImporter.import(markdown_with_missing_ref, kitchen: @kitchen)

  assert_equal 1, recipe.cross_references.count
  assert_predicate recipe.cross_references.first, :pending?
end
```

**Step 6: Update existing cross-reference tests that don't supply target_slug/target_title**

The test `'cross-references link to target recipes'` (line 153) asserts `pizza.cross_references.first.target_slug`. This should still work because `import_cross_reference` now writes the column. No change needed for this assertion.

The test `'imports cross-references with multiplier and prep_note'` (line 256) asserts `ref.target_title`. This should also work because the column is now populated by the importer. No change needed.

**Step 7: Run all importer tests**

Run: `ruby -Itest test/services/markdown_importer_test.rb`
Expected: All tests pass.

**Step 8: Commit**

```bash
git add app/services/markdown_importer.rb test/services/markdown_importer_test.rb
git commit -m "feat: MarkdownImporter always persists cross-references (#91)

Never silently drops cross-references. Unresolved refs are created as
pending and resolved when target recipes become available."
```

---

### Task 3: View — render pending cross-references as plain text

**Files:**
- Modify: `app/views/recipes/_step.html.erb:8-13`
- Modify: `test/controllers/recipes_controller_test.rb` (or create integration test)

**Step 1: Write the failing test**

Add a controller/integration test. In `test/controllers/recipes_controller_test.rb`, add:

```ruby
test 'show renders pending cross-reference as plain text' do
  category = Category.create!(name: 'Main', slug: 'main')
  recipe = Recipe.create!(
    title: 'Pasta', slug: 'pasta', category: category,
    markdown_source: "# Pasta\n\nCategory: Main\n\n## Cook\n\n- Spaghetti\n\nCook."
  )
  step = recipe.steps.create!(title: 'Cook', position: 0)
  step.cross_references.create!(
    target_slug: 'missing-sauce', target_title: 'Missing Sauce',
    position: 0, multiplier: 1.0
  )

  get recipe_path('pasta', kitchen_slug: kitchen_slug)

  assert_response :success
  assert_select 'li.cross-reference b', 'Missing Sauce'
  assert_select 'li.cross-reference a', count: 0
end
```

**Step 2: Run test to verify it fails**

Run: `ruby -Itest test/controllers/recipes_controller_test.rb -n /pending/`
Expected: Test fails (view currently tries to link_to with nil target, or doesn't render at all).

**Step 3: Update the step partial**

In `app/views/recipes/_step.html.erb`, replace lines 8-13:

```erb
<%- if item.respond_to?(:target_slug) -%>
<%- if item.resolved? -%>
<li class="cross-reference"><b><%= link_to item.target_title, recipe_path(item.target_slug) %></b><% if item.multiplier != 1.0 %>, <span class="quantity"><%= item.multiplier == item.multiplier.to_i ? item.multiplier.to_i : item.multiplier %></span><% end %>
<%- else -%>
<li class="cross-reference"><b><%= item.target_title %></b><% if item.multiplier != 1.0 %>, <span class="quantity"><%= item.multiplier == item.multiplier.to_i ? item.multiplier.to_i : item.multiplier %></span><% end %>
<%- end -%>
```

**Step 4: Run tests**

Run: `ruby -Itest test/controllers/recipes_controller_test.rb`
Expected: All tests pass including the new one.

**Step 5: Commit**

```bash
git add app/views/recipes/_step.html.erb test/controllers/recipes_controller_test.rb
git commit -m "feat: render pending cross-references as plain text (#91)

Resolved refs still link to target recipes. Pending refs show the title
without a link, preventing broken links in the UI."
```

---

### Task 4: Seeds — add post-import resolution and warning

**Files:**
- Modify: `db/seeds.rb:43-45`

**Step 1: Update seeds.rb**

After the recipe import loop (line 43), before the "Done!" message, add:

```ruby
# Resolve any cross-references that were deferred during import
CrossReference.resolve_pending(kitchen: kitchen)
pending_count = CrossReference.pending.count
puts "  WARNING: #{pending_count} unresolved cross-references remain" if pending_count.positive?
```

**Step 2: Verify by running seeds**

Run: `rails db:seed`
Expected: No warning about unresolved cross-references (all recipes are imported, all targets exist).

**Step 3: Commit**

```bash
git add db/seeds.rb
git commit -m "feat: seeds resolve deferred cross-references after import (#91)

Safety-net resolution pass after all recipes are imported. Warns if any
cross-references remain unresolved."
```

---

### Task 5: Full test suite and lint

**Step 1: Run the full test suite**

Run: `rake test`
Expected: All tests pass.

**Step 2: Run lint**

Run: `rake lint`
Expected: No lint violations.

**Step 3: Fix any failures**

If any tests fail in other files (e.g., `test/services/cross_reference_updater_test.rb`), update them to include `target_slug:` and `target_title:` when creating CrossReference records.

**Step 4: Commit any remaining fixes**

```bash
git add -A
git commit -m "fix: update remaining tests for deferred cross-references (#91)"
```

---

### Task 6: Close issue

**Step 1: Verify the fix addresses the issue**

Confirm:
- Cross-references are never silently dropped
- Pending refs are created when target doesn't exist
- Refs resolve when target becomes available
- Views handle both resolved and pending refs
- Seeds include a post-import resolution pass

**Step 2: Close the issue**

```bash
gh issue close 91 --comment "Fixed in this branch. Cross-references are now always persisted (even when the target recipe doesn't exist yet) and resolved when targets become available."
```
