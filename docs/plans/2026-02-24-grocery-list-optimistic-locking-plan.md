# GroceryList Optimistic Locking Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers-extended-cc:executing-plans to implement this plan task-by-task.

**Goal:** Eliminate the race condition in GroceryList state mutations by adding Rails optimistic locking with server-side retry.

**Architecture:** Rename the existing `version` column to `lock_version` so Rails auto-checks it on save. Wrap all mutation call sites in a retry loop that catches `StaleObjectError`, reloads the record, and re-applies the action. JSON responses keep the key name `version` for client compatibility.

**Tech Stack:** Rails optimistic locking (built-in), SQLite, Minitest

**Closes:** #86

---

### Task 1: Migration — rename version to lock_version

**Files:**
- Create: `db/migrate/005_rename_grocery_list_version_to_lock_version.rb`
- Modify: `db/schema.rb` (auto-generated by migration)

**Step 1: Write the migration**

```ruby
# frozen_string_literal: true

class RenameGroceryListVersionToLockVersion < ActiveRecord::Migration[8.0]
  def change
    rename_column :grocery_lists, :version, :lock_version
  end
end
```

**Step 2: Run the migration**

Run: `rails db:migrate`
Expected: Schema updates, `grocery_lists` table now has `lock_version` instead of `version`.

**Step 3: Verify schema**

Run: `grep -A 8 'grocery_lists' db/schema.rb`
Expected: Column named `lock_version` with `default: 0`.

**Step 4: Commit**

```bash
git add db/migrate/005_rename_grocery_list_version_to_lock_version.rb db/schema.rb
git commit -m "db: rename grocery_lists.version to lock_version (#86)"
```

---

### Task 2: Model — remove manual version bumps, add retry helper

**Files:**
- Modify: `app/models/grocery_list.rb`
- Test: `test/models/grocery_list_test.rb`

**Step 1: Write failing tests for optimistic locking**

Add these tests to `test/models/grocery_list_test.rb`:

```ruby
test 'defaults to lock_version 0 and empty state' do
  list = GroceryList.create!(kitchen: @kitchen)

  assert_equal 0, list.lock_version
  assert_empty list.state
end

test 'apply_action bumps lock_version' do
  list = GroceryList.for_kitchen(@kitchen)
  old_version = list.lock_version

  list.apply_action('check', item: 'milk', checked: true)

  assert_operator list.lock_version, :>, old_version
end

test 'clear resets state and bumps lock_version' do
  list = GroceryList.for_kitchen(@kitchen)
  list.apply_action('select', type: 'recipe', slug: 'pizza-dough', selected: true)
  old_version = list.lock_version

  list.clear!

  assert_empty list.state
  assert_operator list.lock_version, :>, old_version
end

test 'operations are idempotent for lock_version' do
  list = GroceryList.for_kitchen(@kitchen)
  list.apply_action('check', item: 'milk', checked: true)
  version_after_first = list.lock_version

  list.apply_action('check', item: 'milk', checked: true)

  assert_equal version_after_first, list.lock_version
end

test 'with_optimistic_retry retries on StaleObjectError' do
  list = GroceryList.for_kitchen(@kitchen)
  attempts = 0

  list.with_optimistic_retry do
    attempts += 1
    raise ActiveRecord::StaleObjectError.new(list) if attempts == 1
  end

  assert_equal 2, attempts
end

test 'with_optimistic_retry raises after max attempts' do
  list = GroceryList.for_kitchen(@kitchen)

  assert_raises(ActiveRecord::StaleObjectError) do
    list.with_optimistic_retry(max_attempts: 2) do
      raise ActiveRecord::StaleObjectError.new(list)
    end
  end
end
```

Also **remove** these old tests that reference `list.version` (they'll be replaced by the ones above):
- `'defaults to version 0 and empty state'`
- `'apply_action bumps version'`
- `'clear resets state and bumps version'`
- `'operations are idempotent'`
- `'ignores unknown action types'` — keep but update to use `lock_version`

**Step 2: Run tests to verify they fail**

Run: `ruby -Itest test/models/grocery_list_test.rb`
Expected: New tests fail (no `with_optimistic_retry` method, `lock_version` references may fail depending on migration state).

**Step 3: Update the model**

Replace the full contents of `app/models/grocery_list.rb`:

```ruby
# frozen_string_literal: true

class GroceryList < ApplicationRecord
  acts_as_tenant :kitchen

  validates :kitchen_id, uniqueness: true

  STATE_KEYS = %w[selected_recipes selected_quick_bites custom_items checked_off].freeze
  MAX_RETRY_ATTEMPTS = 3

  def self.for_kitchen(kitchen)
    find_or_create_by!(kitchen: kitchen)
  end

  def apply_action(action_type, **params)
    ensure_state_keys

    case action_type
    when 'select' then apply_select(**params)
    when 'check' then apply_check(**params)
    when 'custom_items' then apply_custom_items(**params)
    end
  end

  def clear!
    self.state = {}
    save!
  end

  def with_optimistic_retry(max_attempts: MAX_RETRY_ATTEMPTS)
    attempts = 0

    begin
      attempts += 1
      yield
    rescue ActiveRecord::StaleObjectError
      raise if attempts >= max_attempts

      reload
      retry
    end
  end

  private

  def ensure_state_keys
    STATE_KEYS.each { |key| state[key] ||= [] }
  end

  def apply_select(type:, slug:, selected:, **)
    key = type == 'recipe' ? 'selected_recipes' : 'selected_quick_bites'
    toggle_array(key, slug, truthy?(selected))
  end

  def apply_check(item:, checked:, **)
    toggle_array('checked_off', item, truthy?(checked))
  end

  def apply_custom_items(item:, action:, **)
    toggle_array('custom_items', item, action == 'add')
  end

  def toggle_array(key, value, add)
    list = state[key]
    already_present = list.include?(value)

    if add && !already_present
      list << value
      save!
    elsif !add && already_present
      list.delete(value)
      save!
    end
  end

  # Controller params arrive as strings; handle both "true"/true
  def truthy?(value)
    [true, 'true'].include?(value)
  end
end
```

Key changes:
- Removed `increment(:version)` — Rails auto-increments `lock_version` on `save!`
- Removed `bump_and_save!` — `toggle_array` and `clear!` call `save!` directly
- Added `with_optimistic_retry` as a public method

**Step 4: Run tests to verify they pass**

Run: `ruby -Itest test/models/grocery_list_test.rb`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add app/models/grocery_list.rb test/models/grocery_list_test.rb
git commit -m "feat: add optimistic locking to GroceryList (#86)

Remove manual version bumps. Rails auto-increments lock_version on save.
Add with_optimistic_retry for callers that need conflict recovery."
```

---

### Task 3: Controller — wrap mutations in retry, return 409 on exhaustion

**Files:**
- Modify: `app/controllers/groceries_controller.rb`
- Test: `test/controllers/groceries_controller_test.rb`

**Step 1: Write failing tests for retry and 409**

Add to `test/controllers/groceries_controller_test.rb`:

```ruby
test 'select retries on concurrent modification' do
  log_in
  list = GroceryList.for_kitchen(@kitchen)

  # Simulate a concurrent update by bumping lock_version in DB
  # between the controller's load and save
  call_count = 0
  original_apply = list.method(:apply_action)
  GroceryList.any_instance.stubs(:apply_action).with do |*_args|
    call_count += 1
    if call_count == 1
      GroceryList.where(id: list.id).update_all(lock_version: list.lock_version + 1)
    end
    true
  end.then_returns(nil)

  # This approach is fragile — instead test at the model level (Task 2)
  # and test the controller's 409 response via a stub
end

test 'select returns 409 when retry exhausted' do
  log_in
  GroceryList.any_instance.stubs(:apply_action).raises(ActiveRecord::StaleObjectError.new(GroceryList.new))

  patch groceries_select_path(kitchen_slug: kitchen_slug),
        params: { type: 'recipe', slug: 'focaccia', selected: true },
        as: :json

  assert_response :conflict
  json = JSON.parse(response.body)

  assert_equal 'Grocery list was modified by another request. Please refresh.', json['error']
end

test 'check returns 409 when retry exhausted' do
  log_in
  GroceryList.any_instance.stubs(:apply_action).raises(ActiveRecord::StaleObjectError.new(GroceryList.new))

  patch groceries_check_path(kitchen_slug: kitchen_slug),
        params: { item: 'flour', checked: true },
        as: :json

  assert_response :conflict
end

test 'clear returns 409 when retry exhausted' do
  log_in
  GroceryList.any_instance.stubs(:clear!).raises(ActiveRecord::StaleObjectError.new(GroceryList.new))

  delete groceries_clear_path(kitchen_slug: kitchen_slug), as: :json

  assert_response :conflict
end
```

**Step 2: Run tests to verify they fail**

Run: `ruby -Itest test/controllers/groceries_controller_test.rb -n /409/`
Expected: Failures — controller doesn't handle `StaleObjectError` yet.

**Step 3: Update the controller**

Replace `apply_and_respond` and `clear` in `app/controllers/groceries_controller.rb`:

```ruby
# frozen_string_literal: true

class GroceriesController < ApplicationController
  before_action :require_membership

  rescue_from ActiveRecord::StaleObjectError, with: :handle_stale_record

  def show
    @categories = current_kitchen.categories.ordered.includes(recipes: { steps: :ingredients })
    @quick_bites_by_subsection = load_quick_bites_by_subsection
    @quick_bites_content = current_kitchen.quick_bites_content || ''
  end

  def state
    list = GroceryList.for_kitchen(current_kitchen)
    shopping_list = ShoppingListBuilder.new(kitchen: current_kitchen, grocery_list: list).build

    render json: {
      version: list.lock_version,
      **list.state.slice(*GroceryList::STATE_KEYS),
      shopping_list: shopping_list
    }
  end

  def select
    apply_and_respond('select',
                      type: params[:type],
                      slug: params[:slug],
                      selected: params[:selected])
  end

  def check
    apply_and_respond('check',
                      item: params[:item],
                      checked: params[:checked])
  end

  def update_custom_items
    apply_and_respond('custom_items',
                      item: params[:item],
                      action: params[:action_type])
  end

  def clear
    list = GroceryList.for_kitchen(current_kitchen)
    list.with_optimistic_retry { list.clear! }
    GroceryListChannel.broadcast_version(current_kitchen, list.lock_version)
    render json: { version: list.lock_version }
  end

  def update_quick_bites
    content = params[:content].to_s
    return render json: { errors: ['Content cannot be blank.'] }, status: :unprocessable_entity if content.blank?

    current_kitchen.update!(quick_bites_content: content)

    GroceryListChannel.broadcast_content_changed(current_kitchen)
    render json: { status: 'ok' }
  end

  def update_aisle_order
    current_kitchen.aisle_order = params[:aisle_order].to_s
    current_kitchen.normalize_aisle_order!
    current_kitchen.save!

    list = GroceryList.for_kitchen(current_kitchen)
    list.with_optimistic_retry { list.save! }
    GroceryListChannel.broadcast_version(current_kitchen, list.lock_version)
    render json: { status: 'ok' }
  end

  def aisle_order_content
    render json: { aisle_order: build_aisle_order_text }
  end

  private

  def apply_and_respond(action_type, **action_params)
    list = GroceryList.for_kitchen(current_kitchen)
    list.with_optimistic_retry do
      list.apply_action(action_type, **action_params)
    end
    GroceryListChannel.broadcast_version(current_kitchen, list.lock_version)
    render json: { version: list.lock_version }
  end

  def handle_stale_record
    render json: { error: 'Grocery list was modified by another request. Please refresh.' },
           status: :conflict
  end

  def build_aisle_order_text
    current_kitchen.all_aisles.join("\n")
  end

  def load_quick_bites_by_subsection
    content = current_kitchen.quick_bites_content
    return {} unless content

    FamilyRecipes.parse_quick_bites_content(content)
                 .group_by { |qb| qb.category.delete_prefix('Quick Bites: ') }
  end
end
```

Key changes:
- All `list.version` references → `list.lock_version`
- `apply_and_respond` wraps `apply_action` in `with_optimistic_retry`
- `clear` wraps `clear!` in `with_optimistic_retry`
- `update_aisle_order` uses `with_optimistic_retry` instead of `increment!(:version)`
- Added `rescue_from ActiveRecord::StaleObjectError` → 409 Conflict
- JSON response uses `version: list.lock_version` (client-compatible key name)

**Step 4: Run tests to verify they pass**

Run: `ruby -Itest test/controllers/groceries_controller_test.rb`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add app/controllers/groceries_controller.rb test/controllers/groceries_controller_test.rb
git commit -m "feat: wrap grocery mutations in optimistic retry (#86)

Return 409 Conflict when retries exhausted. JSON responses keep
'version' key for client compatibility, backed by lock_version column."
```

---

### Task 4: Update existing tests and channel

**Files:**
- Modify: `test/models/grocery_list_test.rb` (remove old `version` references)
- Modify: `test/controllers/groceries_controller_test.rb` (update `version` assertions)
- Modify: `app/channels/grocery_list_channel.rb` (no change needed — it receives version as an argument)

**Step 1: Update model test references**

In `test/models/grocery_list_test.rb`, replace the old test `'ignores unknown action types'`:

```ruby
test 'ignores unknown action types' do
  list = GroceryList.for_kitchen(@kitchen)
  old_version = list.lock_version

  list.apply_action('bogus', foo: 'bar')

  assert_equal old_version, list.lock_version
end
```

Also verify the controller test at line 247 (`assert_equal 0, json['version']`) — this already checks the JSON key `version` which the controller now populates from `lock_version`. No change needed.

**Step 2: Run the full test suite**

Run: `rake test`
Expected: All tests pass, zero failures.

**Step 3: Run lint**

Run: `rake lint`
Expected: No new offenses.

**Step 4: Commit**

```bash
git add test/models/grocery_list_test.rb
git commit -m "test: update grocery list tests to use lock_version (#86)"
```

---

### Task 5: Final verification and cleanup

**Step 1: Run the full suite one last time**

Run: `rake`
Expected: Lint passes, all tests pass.

**Step 2: Smoke test with dev server**

Run: `bin/dev` (in background)
1. Open groceries page
2. Select a recipe — verify it appears in the shopping list
3. Check off an item — verify it persists across reload
4. Clear the list — verify it resets

**Step 3: Verify the lock_version behavior manually**

Open a Rails console (`rails console`) and verify:
```ruby
list = GroceryList.first
old = list.lock_version
list.apply_action('check', item: 'test', checked: true)
list.lock_version > old  # => true
```

**Step 4: Final commit (if any cleanup needed)**

If no cleanup is needed, skip this step.
